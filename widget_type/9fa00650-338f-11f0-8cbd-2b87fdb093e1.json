{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "somat_rio_do_per_odo",
    "name" : "Somatório do Período",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "timeseries",
      "sizeX" : 8,
      "sizeY" : 5.5,
      "resources" : [ ],
      "templateHtml" : "<mat-card\n    [ngStyle]=\"{'background-color': numericCurrentConsumption > numericLastConsumption ? 'rgba(219, 50, 35, 0.9)' : 'unset', \n    'color': numericCurrentConsumption > numericLastConsumption ? '#ffffff' : 'unset'}\"\n    class=\"myio-comparativeConsumption-card\">\n     \n    <mat-card-content class=\"myio-comparativeConsumption-card-header\">\n       <div>  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32px\" height=\"32px\" viewBox=\"0 -880 960 960\"  fill=\"#fcba03\">\n            <path d=\"m456-200 174-340H510v-220L330-420h126v220Zm24 120q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5-156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z\"/>\n        </svg>\n        </div>\n        <!-- Loading and Error States -->\n        <div *ngIf=\"isLoading\" class=\"myio-loading-message\">Carregando...</div>\n        <div *ngIf=\"errorMessage && !isLoading\" class=\"myio-error-message\">{{errorMessage}}</div>\n\n        <div *ngIf=\"!isLoading && !errorMessage\" class=\"myio-header-percentages\">\n            <span class=\"myio-icon\">{{percentages}}%</span>\n                <svg *ngIf=\"numericLastConsumption > numericCurrentConsumption\" xmlns=\"http://www.w3.org/2000/svg\" height=\"35px\" viewBox=\"0 -960 960 960\" width=\"35px\" style=\"fill: currentColor;\">\n                    <path d=\"M440-240v-368L296-464l-56-56 240-240 240 240-56 56-144-144v368h-80Z\"/>\n                </svg>\n                <svg *ngIf=\"numericLastConsumption < numericCurrentConsumption\" xmlns=\"http://www.w3.org/2000/svg\" height=\"35px\" viewBox=\"0 -960 960 960\" width=\"35px\" style=\"fill: currentColor;\">\n                    <path d=\"M480-240 240-480l56-56 144 144v-368h80v368l144-144 56 56-240 240Z\"/>\n                </svg>\n        </div> \n    </mat-card-content>\n    <mat-card-content *ngIf=\"!isLoading && !errorMessage\" class=\"myio-comparativeConsumption-card-content\">\n        <mat-card-content class=\"card-content\">\n            <mat-card-title class=\"content-telemetry-title\">{{title}} {{entityName}}</mat-card-title>\n            <mat-card-title class=\"content-telemetry-consumption\">{{currentConsumption}} {{measurement}}</mat-card-title>\n        </mat-card-content>\n        <mat-card-content class=\"card-content\">\n            <mat-card-title class=\"content-latest-telemetry-title\">Último periodo:</mat-card-title>\n            <mat-card-title class=\"content-latest-telemetry-consumption\">{{lastConsumption}} {{measurement}}</mat-card-title>\n        </mat-card-content>\n    </mat-card-content>\n\n    <mat-card-footer class=\"myio-comparativeConsumption-card-footer\">\n        \n    </mat-card-footer>    \n</mat-card>",
      "templateCss" : ".myio-comparativeConsumption-card{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    box-shadow: none;\n}\n.myio-comparativeConsumption-card-content{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: space-evenly;\n}\n\n\n.myio-comparativeConsumption-card-header {\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start; \n}\n\n.myio-svg-container {\n    display: flex;\n    align-items: center;\n}\n\n.myio-header-percentages {\n    display: flex;\n    align-items: center; \n    font-size: 12px !important;\n}\n\n.myio-icon{\n    font-size: 20px;\n}\n\n.card-content{\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.content-telemetry-title{\n    text-align: center;\n    font-size: 18px;\n\n}\n.content-telemetry-consumption{\n    font-size: 24px;\n    font-weight: bold\n}\n.content-latest-telemetry-title{\n    font-weight: 400;\n    text-align: center;\n    font-size: 12px;\n}\n.content-latest-telemetry-consumption{\n    font-size: 13px;\n}",
      "controllerScript" : "function percentage(totalConsumptionLastMonth, totalConsumptionThisMonth) {\n    if (totalConsumptionLastMonth === 0) {\n        return 0; // evita divisao por zero se o consumo do mes passado for 0\n    }\n\n    if (totalConsumptionLastMonth > totalConsumptionThisMonth) {\n        return ((totalConsumptionLastMonth - totalConsumptionThisMonth) * 100) / totalConsumptionLastMonth;\n    } else if (totalConsumptionLastMonth < totalConsumptionThisMonth) {\n        // aumento no consumo: calcula a porcentagem de aumento em relacaoo ao mes passado\n        return ((totalConsumptionThisMonth - totalConsumptionLastMonth) * 100) / totalConsumptionLastMonth;\n    } else {\n        // consumos iguais: não tem variacao\n        return 0;\n    }\n}\n\nfunction getData(startTs, endTs) {\n    const datasource = self.ctx.datasources[0]\n    const dataKey = datasource.dataKeys[0]; \n    const deviceIds = datasource.entity.id.id;\n    const attributeService = self.ctx.attributeService;\n    \n   //// console.log('datasource', datasource)\n   // console.log('dataKey', dataKey)\n   // console.log('deviceIds', deviceIds)\n    \n    \n    return attributeService.getEntityTimeseries(\n        {\n            entityType: 'DEVICE',\n            id: deviceIds,\n        },\n        [dataKey.name], \n        startTs,\n        endTs,\n        null,\n        'SUM',\n        8000000\n    )\n    .toPromise()\n    .then((data)=>{\n        if(!data || !data[dataKey.name]){\n            console.error(\"Erro: Dados ausentes ou invelidados\", data);\n            return 0;\n        }\n\n        \n        const whData = data[dataKey.name]; \n        let totalConsumption = 0;\n\n        whData.forEach(entry => {\n            totalConsumption += parseFloat(entry.value);\n        });\n\n\n        return totalConsumption/1000; \n            \n        })\n        .catch((error) => {\n            console.error(\"Erro ao obter dados:\", error);\n        });\n        \n\n}\n\nasync function sum(startTs, endTs) {\n    const datasources = self.ctx.datasources;\n    const attributeService = self.ctx.attributeService;\n\n    // Pegando todos os dataKeys e deviceIds\n    const deviceRequests = datasources.map((datasource) => {\n        const dataKey = datasource.dataKeys[0]; \n        const deviceId = datasource.entity?.id?.id;\n\n        if (!dataKey || !deviceId) return null; // Se faltar algo, ignora esse dispositivo\n\n        // Retorna a promessa da requisição\n        return attributeService.getEntityTimeseries(\n            {\n                entityType: 'DEVICE',\n                id: deviceId,\n            },\n            [dataKey.name], \n            startTs,\n            endTs,\n            null,\n            'SUM',\n            8000000\n        )\n        .toPromise()\n        .then((data) => {\n            if (!data || !data[dataKey.name]) {\n                console.error(`Erro: Dados ausentes para dispositivo ${deviceId}`, data);\n                return 0;\n            }\n\n            // Somando os valores do dispositivo específico\n            return data[dataKey.name].reduce((total, entry) => total + parseFloat(entry.value), 0);\n        })\n        .catch((error) => {\n            console.error(`Erro ao obter dados do dispositivo ${deviceId}:`, error);\n            return 0; // Se der erro, assume 0\n        });\n    }).filter(Boolean); // Remove os `null` do array\n\n    // Aguarda todas as requisições e soma os resultados\n    const consumptionValues = await Promise.all(deviceRequests);\n    const totalConsumption = consumptionValues.reduce((sum, value) => sum + value, 0);\n    console.log(\"consumptionValues\",consumptionValues)\n    console.log(\"totalConsumption\",totalConsumption/1000)\n    return totalConsumption / 1000; // Convertendo para kWh\n}\n\n\nfunction lessMonthDate(timestape){\n    const date = new Date(timestape);\n    date.setMonth(date.getMonth()-1)\n    return date.getTime();\n}\n\nfunction formatTimestamp(timestamp) {\n    const date = new Date(timestamp);\n\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n\n    return `${day}/${month}/${year}`;\n}\n\nself.onInit = async function() {\n    // Initialize scope variables\n    self.ctx.$scope.title = self.ctx.settings.title || 'Consumo Comparativo';\n    self.ctx.$scope.measurement = self.ctx.settings.measurement || 'kWh';\n    self.ctx.$scope.entityName = self.ctx.defaultSubscription.data[0]?.datasource.entityName || '';\n    self.ctx.$scope.currentConsumption = '...';\n    self.ctx.$scope.lastConsumption = '...';\n    self.ctx.$scope.percentages = '...';\n    self.ctx.$scope.errorMessage = null;\n    self.ctx.$scope.isLoading = true;\n\n    // Store API base URL from settings\n    self.apiBaseUrl = 'https://ingestion.myio-bas.com'; //self.ctx.settings.apiBaseUrl;\n    if (!self.apiBaseUrl) {\n        self.ctx.$scope.errorMessage = 'API Base URL não configurado nas definições do widget.';\n        self.ctx.$scope.isLoading = false;\n        self.ctx.detectChanges();\n        return;\n    }\n\n    // Fetch device attributes for gatewayId and slaveId\n    try {\n        const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n        const { entityId, entityType } = self.ctx.defaultSubscription.data[0].datasource;\n        \n        const gatewayIdAttrName = self.ctx.settings.gatewayIdAttributeName || 'centralId';\n        const slaveIdAttrName = self.ctx.settings.slaveIdAttributeName || 'slaveId';\n\n        const attributes = await attributeService.getEntityAttributes(\n            { id: entityId, entityType },\n            'SERVER_SCOPE',\n            [gatewayIdAttrName, slaveIdAttrName]\n        ).toPromise();\n\n        const gatewayIdAttr = attributes.find(attr => attr.key === gatewayIdAttrName);\n        const slaveIdAttr = attributes.find(attr => attr.key === slaveIdAttrName);\n\n        self.gatewayId = gatewayIdAttr ? gatewayIdAttr.value : null;\n        self.slaveId = slaveIdAttr ? slaveIdAttr.value : null;\n\n        if (!self.gatewayId || !self.slaveId) {\n            self.ctx.$scope.errorMessage = `Atributos '${gatewayIdAttrName}' ou '${slaveIdAttrName}' não encontrados no dispositivo.`;\n            self.ctx.$scope.isLoading = false;\n            self.ctx.detectChanges();\n            return;\n        }\n    } catch (e) {\n        console.error('Erro ao buscar atributos do dispositivo:', e);\n        self.ctx.$scope.errorMessage = 'Erro ao buscar atributos do dispositivo.';\n        self.ctx.$scope.isLoading = false;\n        self.ctx.detectChanges();\n        return;\n    }\n\n    await fetchDataAndUpdateScope();\n};\n\nasync function fetchDataAndUpdateScope() {\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null;\n\n    const timeWindow = self.ctx.timeWindow;\n    if (!timeWindow || typeof timeWindow.minTime === 'undefined' || typeof timeWindow.maxTime === 'undefined') {\n        self.ctx.$scope.errorMessage = 'Janela de tempo não disponível.';\n        self.ctx.$scope.isLoading = false;\n        self.ctx.detectChanges();\n        return;\n    }\n\n    const startTs = new Date(timeWindow.minTime).toISOString();\n    const endTs = new Date(timeWindow.maxTime).toISOString();\n\n    try {\n        const comparisonData = await fetchEnergyComparisonSum({\n            gatewayId: self.gatewayId,\n            slaveId: self.slaveId,\n            startTs: startTs,\n            endTs: endTs,\n            apiBaseUrl: self.apiBaseUrl\n        });\n\n        const currentKwh = comparisonData.currentPeriod.totalKwh;\n        const previousKwh = comparisonData.previousPeriod.totalKwh;\n        \n        const displayLocale = self.ctx.settings.displayLocale || 'pt-BR';\n        const numberFormatOptions = { minimumFractionDigits: 2, maximumFractionDigits: 2 };\n\n        self.ctx.$scope.currentConsumption = currentKwh.toLocaleString(displayLocale, numberFormatOptions);\n        self.ctx.$scope.lastConsumption = previousKwh.toLocaleString(displayLocale, numberFormatOptions);\n        \n        const calculatedPercentage = calculatePercentageDifference(previousKwh, currentKwh);\n        self.ctx.$scope.percentages = calculatedPercentage.percentage.toLocaleString(displayLocale, {minimumFractionDigits: 0, maximumFractionDigits: 0});\n        \n        // These are for the ngStyle conditional background/color and icons in HTML\n        self.ctx.$scope.numericCurrentConsumption = currentKwh;\n        self.ctx.$scope.numericLastConsumption = previousKwh;\n        \n\n    } catch (error) {\n        console.error('Erro ao buscar dados de comparação de energia:', error);\n        self.ctx.$scope.errorMessage = error.message || 'Falha ao carregar dados.';\n        self.ctx.$scope.currentConsumption = 'Erro';\n        self.ctx.$scope.lastConsumption = 'Erro';\n        self.ctx.$scope.percentages = '-';\n    }\n    self.ctx.$scope.isLoading = false;\n    self.ctx.detectChanges();\n}\n\nasync function fetchEnergyComparisonSum(params) {\n    const { gatewayId, slaveId, startTs, endTs, apiBaseUrl } = params;\n\n    if (!gatewayId || !slaveId || !startTs || !endTs || !apiBaseUrl) {\n      throw new Error(\n        'fetchEnergyComparisonSum: Parâmetros gatewayId, slaveId, startTs, endTs e apiBaseUrl são obrigatórios.'\n      );\n    }\n\n    const apiUrl = new URL('/api/v1/energy-readings/comparison-sum', apiBaseUrl);\n    apiUrl.searchParams.set('gatewayId', gatewayId);\n    apiUrl.searchParams.set('slaveId', String(slaveId));\n    apiUrl.searchParams.set('startTs', startTs);\n    apiUrl.searchParams.set('endTs', endTs);\n\n    const response = await fetch(apiUrl.toString());\n\n    if (!response.ok) {\n        let errorData = { error: 'Falha na requisição à API.' };\n        try {\n            errorData = await response.json();\n        } catch (e) {\n            // Ignore if response is not JSON\n        }\n        throw new Error(\n            `API request failed with status ${response.status}. ${errorData.error || response.statusText}`\n        );\n    }\n    return await response.json(); \n}\n\n// Mantém a lógica de cálculo de percentual, mas pode ser simplificada.\n// Retorna objeto com 'percentage' e 'type' ('increase', 'decrease', 'equal')\nfunction calculatePercentageDifference(previousValue, currentValue) {\n    if (previousValue === null || previousValue === undefined || currentValue === null || currentValue === undefined) {\n        return { percentage: 0, type: 'equal' }; \n    }\n\n    if (previousValue === 0) {\n        if (currentValue > 0) return { percentage: 100, type: 'increase' }; // Ou Infinity, ou tratar como grande aumento\n        return { percentage: 0, type: 'equal' };\n    }\n\n    let percentageDiff;\n    let type;\n\n    if (currentValue > previousValue) {\n        percentageDiff = ((currentValue - previousValue) / previousValue) * 100;\n        type = 'increase';\n    } else if (currentValue < previousValue) {\n        percentageDiff = ((previousValue - currentValue) / previousValue) * 100;\n        type = 'decrease';\n    } else {\n        percentageDiff = 0;\n        type = 'equal';\n    }\n    return { percentage: percentageDiff, type: type };\n}\n\nself.onTimewindowChanged = async function(timeWindow) {\n    // console.log('Time window changed:', timeWindow);\n    if (self.gatewayId && self.slaveId && self.apiBaseUrl) { // Ensure IDs and URL are loaded\n        await fetchDataAndUpdateScope();\n    }\n};\n\nself.onDataUpdated = async function() {\n    // This is typically called for datasource updates, which we are not directly using for fetching anymore.\n    // However, it might be triggered after onInit or if other subscriptions change.\n    // Re-calling fetchData to ensure consistency if timeWindow might have changed implicitly.\n    // console.log('onDataUpdated called');\n    if (self.gatewayId && self.slaveId && self.apiBaseUrl) {\n         await fetchDataAndUpdateScope();\n    }\n};\n\n\n// self.onLatestDataUpdated = function() {\n//      self.ctx.detectChanges();   \n// }\n\n\n",
      "settingsSchema" : "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"type\": \"string\",\r\n                \"title\": \"Título do Card\"\r\n            },\r\n            \"measurement\":{\r\n                \"type\":\"string\",\r\n                \"title\":\"Tipo de medição\"\r\n            }\r\n            \r\n        },\r\n        \"required\": [\"title\"]\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n        \"measurement\"\r\n        \r\n        \r\n    ]\r\n}",
      "dataKeySettingsSchema" : "{}",
      "latestDataKeySettingsSchema" : "{}",
      "settingsDirective" : "",
      "dataKeySettingsDirective" : "",
      "latestDataKeySettingsDirective" : "tb-value-card-widget-settings",
      "hasBasicMode" : true,
      "basicModeDirective" : "",
      "defaultConfig" : "{\"showTitle\":false,\"backgroundColor\":\"rgba(0, 0, 0, 0)\",\"color\":\"rgba(33, 186, 79, 0.87)\",\"padding\":\"0px\",\"settings\":{\"title\":\"Título do Card\"},\"title\":\"Somatório do Período\",\"dropShadow\":true,\"enableFullscreen\":false,\"titleStyle\":null,\"mobileHeight\":null,\"configMode\":\"advanced\",\"actions\":{},\"showTitleIcon\":false,\"titleIcon\":\"thermostat\",\"iconColor\":\"#1F6BDD\",\"useDashboardTimewindow\":false,\"displayTimewindow\":false,\"titleFont\":{\"size\":16,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"500\",\"style\":\"normal\",\"lineHeight\":\"24px\"},\"titleColor\":\"rgba(0, 0, 0, 0.87)\",\"titleTooltip\":\"\",\"widgetStyle\":{},\"widgetCss\":\"\",\"pageSize\":1024,\"units\":\"\",\"decimals\":null,\"noDataDisplayMessage\":\"\",\"timewindowStyle\":{\"showIcon\":false,\"iconSize\":\"24px\",\"icon\":null,\"iconPosition\":\"left\",\"font\":{\"size\":12,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"400\",\"style\":\"normal\",\"lineHeight\":\"16px\"},\"color\":\"rgba(0, 0, 0, 0.38)\",\"displayTypePrefix\":true},\"margin\":\"0px\",\"borderRadius\":\"0px\",\"iconSize\":\"0px\",\"timewindow\":{\"realtime\":{\"timewindowMs\":86400000}},\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.0049099568976449515,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin 2\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.29530602333210765,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"}],\"alarmFilterConfig\":{\"statusList\":[\"ACTIVE\"]}}],\"enableDataExport\":false}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "9fa00650-338f-11f0-8cbd-2b87fdb093e1"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}