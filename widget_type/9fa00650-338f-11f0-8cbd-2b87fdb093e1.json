{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "somat_rio_do_per_odo",
    "name" : "Somatório do Período",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "timeseries",
      "sizeX" : 8,
      "sizeY" : 5.5,
      "resources" : [ {
        "url" : "https://graphs.ingestion.myio-bas.com/sdk/energy-chart-sdk.umd.js"
      } ],
      "templateHtml" : "<mat-card\n    [ngStyle]=\"{'background-color': numericCurrentConsumption > numericLastConsumption ? 'rgba(219, 50, 35, 0.9)' : 'unset', \n    'color': numericCurrentConsumption > numericLastConsumption ? '#ffffff' : 'unset'}\"\n    class=\"myio-comparativeConsumption-card\">\n     \n    <mat-card-content class=\"myio-comparativeConsumption-card-header\">\n       <div>  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32px\" height=\"32px\" viewBox=\"0 -880 960 960\"  fill=\"#fcba03\">\n            <path d=\"m456-200 174-340H510v-220L330-420h126v220Zm24 120q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5-156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z\"/>\n        </svg>\n        </div>\n        <!-- Loading and Error States -->\n        <div *ngIf=\"isLoading\" class=\"myio-loading-message\">Carregando...</div>\n        <div *ngIf=\"errorMessage && !isLoading\" class=\"myio-error-message\">{{errorMessage}}</div>\n\n        <div *ngIf=\"!isLoading && !errorMessage\" class=\"myio-header-percentages\">\n            <span class=\"myio-icon\">{{percentages}}%</span>\n                <svg *ngIf=\"percentageType === 'decrease'\" xmlns=\"http://www.w3.org/2000/svg\" height=\"35px\" viewBox=\"0 -960 960 960\" width=\"35px\" style=\"fill: currentColor;\">\n                    <path d=\"M440-240v-368L296-464l-56-56 240-240 240 240-56 56-144-144v368h-80Z\"/>\n                </svg>\n                <svg *ngIf=\"percentageType === 'increase'\" xmlns=\"http://www.w3.org/2000/svg\" height=\"35px\" viewBox=\"0 -960 960 960\" width=\"35px\" style=\"fill: currentColor;\">\n                    <path d=\"M480-240 240-480l56-56 144 144v-368h80v368l144-144 56 56-240 240Z\"/>\n                </svg>\n        </div> \n    </mat-card-content>\n    <mat-card-content *ngIf=\"!isLoading && !errorMessage\" class=\"myio-comparativeConsumption-card-content\">\n        <mat-card-content class=\"card-content\">\n            <mat-card-title class=\"content-telemetry-title\">{{title}} {{entityName}}</mat-card-title>\n            <mat-card-title class=\"content-telemetry-consumption\">{{currentConsumption}} {{measurement}}</mat-card-title>\n        </mat-card-content>\n        <mat-card-content class=\"card-content\">\n            <mat-card-title class=\"content-latest-telemetry-title\">Último periodo:</mat-card-title>\n            <mat-card-title class=\"content-latest-telemetry-consumption\">{{lastConsumption}} {{measurement}}</mat-card-title>\n        </mat-card-content>\n    </mat-card-content>\n\n    <mat-card-footer class=\"myio-comparativeConsumption-card-footer\">\n        \n    </mat-card-footer>    \n</mat-card>",
      "templateCss" : ".myio-comparativeConsumption-card{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    box-shadow: none;\n}\n.myio-comparativeConsumption-card-content{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: space-evenly;\n}\n\n\n.myio-comparativeConsumption-card-header {\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start; \n}\n\n.myio-svg-container {\n    display: flex;\n    align-items: center;\n}\n\n.myio-header-percentages {\n    display: flex;\n    align-items: center; \n    font-size: 12px !important;\n}\n\n.myio-icon{\n    font-size: 20px;\n}\n\n.card-content{\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.content-telemetry-title{\n    text-align: center;\n    font-size: 18px;\n\n}\n.content-telemetry-consumption{\n    font-size: 24px;\n    font-weight: bold\n}\n.content-latest-telemetry-title{\n    font-weight: 400;\n    text-align: center;\n    font-size: 12px;\n}\n.content-latest-telemetry-consumption{\n    font-size: 13px;\n}",
      "controllerScript" : "// Helper function to format a millisecond timestamp to YYYY-MM-DD\nfunction formatDateToYMD(timestampMs, tzIdentifier) {\n    const date = new Date(timestampMs);\n    const formatter = new Intl.DateTimeFormat('default', {\n        timeZone: tzIdentifier,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit'\n    });\n    \n    const parts = formatter.formatToParts(date);\n    const year = parts.find(p => p.type === 'year').value;\n    const month = parts.find(p => p.type === 'month').value;\n    const day = parts.find(p => p.type === 'day').value;\n    \n    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\n}\n\n// Helper function to determine a suitable interval based on time duration\nfunction determineInterval(startTimeMs, endTimeMs) {\n    const durationMs = endTimeMs - startTimeMs;\n    const durationDays = durationMs / (1000 * 60 * 60 * 24);\n\n    console.log('Duration days: ', durationDays);\n    if (durationDays > 2) { // More than 2 days\n        return '1 month';\n    } else { // 2 days or less\n        return '1 day';\n    }\n}\n\nself.onInit = async function() {\n    // Initialize scope variables for the template\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null;\n    self.ctx.$scope.title = self.ctx.settings.title || \"Consumo Energético\";\n    self.ctx.$scope.entityName = \"\"; \n    self.ctx.$scope.percentages = \"--\";\n    self.ctx.$scope.percentageType = 'neutral'; // 'increase', 'decrease'\n    self.ctx.$scope.currentConsumption = \"Carregando...\";\n    self.ctx.$scope.lastConsumption = \"Carregando...\";\n    self.ctx.$scope.measurement = self.ctx.settings.measurementUnit || \"kWh\";\n    self.ctx.$scope.numericCurrentConsumption = null;\n    self.ctx.$scope.numericLastConsumption = null;\n    self.ctx.$scope.apiBaseUrl = self.ctx.settings.apiBaseUrl || 'https://ingestion.myio-bas.com'; // Store for API calls\n\n    // For storing attributes directly on self for quicker/safer access before scope applies\n    self.centralId = null;\n    self.slaveId = null;\n    self.attributesReady = false;\n\n\n    // Attempt to get entity name first from aliasController or subscription entityTitle\n    if (self.ctx.aliasController && typeof self.ctx.aliasController.getEntity === 'function') {\n        const entity = self.ctx.aliasController.getEntity();\n        if (entity && entity.name) self.ctx.$scope.entityName = entity.name;\n    } else if (self.ctx.aliasController && self.ctx.aliasController.entity && self.ctx.aliasController.entity.name) {\n        self.ctx.$scope.entityName = self.ctx.aliasController.entity.name;\n    } else if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.entityTitle) {\n        self.ctx.$scope.entityName = self.ctx.defaultSubscription.entityTitle;\n    }\n\n\n    self.chartInstance = null;\n    self.chartContainerElement = document.createElement('div');\n    self.chartContainerElement.style.width = '100%';\n    self.chartContainerElement.style.height = '100%';\n    self.chartContainerElement.style.minHeight = '300px';\n    self.ctx.$container.append(self.chartContainerElement);\n\n    try {\n        const attributeService = self.ctx.$scope.$injector.get(\n            self.ctx.servicesMap.get('attributeService'));\n            \n        let entityId, entityType;\n\n        if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.datasources && self.ctx.defaultSubscription.datasources.length > 0) {\n            const firstDatasource = self.ctx.defaultSubscription.datasources[0];\n            entityId = firstDatasource.entityId;\n            entityType = firstDatasource.entityType;\n            if (!self.ctx.$scope.entityName && firstDatasource.entityName) { // If entityName wasn't set by alias/subscription title\n                 self.ctx.$scope.entityName = firstDatasource.entityName;\n            }\n        }\n\n        if (!entityId || !entityType) {\n            console.error(\"sum-with-comparison: EntityId or EntityType could not be determined from datasources. Widget might not function correctly.\");\n            self.ctx.$scope.errorMessage = \"Contexto do dispositivo não encontrado (entityId/entityType).\";\n            self.ctx.$scope.isLoading = false;\n            self.attributesReady = false; // Explicitly set\n            self.ctx.detectChanges();\n            return;\n        }\n        \n        console.log(`sum-with-comparison: Using entityId: ${entityId}, entityType: ${entityType} for attribute fetching.`);\n\n        const deviceAttributes = await attributeService.getEntityAttributes(\n            { id: entityId, entityType: entityType },\n            'SERVER_SCOPE',\n            ['centralId', 'slaveId']\n        ).toPromise();\n        console.log('dev attributes', deviceAttributes);\n        \n        const centralIdAttr = deviceAttributes.find(attribute => attribute.key === 'centralId');\n        const slaveIdAttr = deviceAttributes.find(attribute => attribute.key === 'slaveId');\n\n        const centralIdValue = centralIdAttr ? centralIdAttr.value : null;\n        const slaveIdStrValue = slaveIdAttr ? slaveIdAttr.value : null;\n        const slaveIdValue = slaveIdStrValue ? parseInt(slaveIdStrValue) : null;\n\n        console.log(`sum-with-comparison: Parsed attribute values - centralIdValue: ${centralIdValue} (type: ${typeof centralIdValue}), slaveIdValue: ${slaveIdValue} (type: ${typeof slaveIdValue})`);\n\n        if (!centralIdValue || slaveIdValue === null || isNaN(slaveIdValue)) {\n            console.error(`sum-with-comparison: Missing or invalid device attributes after parsing: centralId='${centralIdValue}', slaveId='${slaveIdValue}'. Cannot initialize chart or fetch API data.`);\n            self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">Erro: Atributos do dispositivo ausentes ou inválidos (centralId ou slaveId). Verifique os atributos do servidor do dispositivo.</div>`;\n            self.ctx.$scope.errorMessage = \"Erro nos atributos do dispositivo (centralId/slaveId).\";\n            self.attributesReady = false; // Explicitly set\n            // isLoading will be handled by onDataUpdated or finally block if chart init is also affected\n        } else {\n            self.centralId = centralIdValue;\n            self.slaveId = slaveIdValue;\n            self.ctx.$scope.centralId = centralIdValue; // Also update scope\n            self.ctx.$scope.slaveId = slaveIdValue;     // Also update scope\n            self.attributesReady = true;\n            console.log(`sum-with-comparison: Attributes ready flag set to true. centralId=${self.centralId}, slaveId=${self.slaveId}`);\n            \n            // Initialize chart only if attributes are successfully fetched\n            initChart(self.slaveId, self.centralId, self.ctx.timeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo');\n        }\n        \n    } catch (e) {\n        console.error('sum-with-comparison: Error fetching device attributes or initializing chart:', e);\n        self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">Erro ao inicializar: ${e.message || 'Erro desconhecido'}</div>`;\n        self.ctx.$scope.errorMessage = self.ctx.$scope.errorMessage || `Erro na inicialização: ${e.message || 'Erro desconhecido'}`;\n        self.attributesReady = false; // Explicitly set\n    } finally {\n        // isLoading will be set to false in onDataUpdated after the first API call attempt.\n        // If onInit fails catastrophically before onDataUpdated can run, set it here.\n        if (!self.attributesReady && self.ctx.$scope.isLoading) {\n            // self.ctx.$scope.isLoading = false; // Let onDataUpdated handle this for now to avoid premature UI flicker\n        }\n        self.ctx.detectChanges(); // Ensure initial UI updates from onInit are applied\n    }\n};\n\nfunction initChart(slaveId, centralId, initialTimezone) {\n    // Destroy previous instance if it exists\n    if (self.chartInstance && typeof self.chartInstance.destroy === 'function') {\n        self.chartInstance.destroy();\n        self.chartInstance = null;\n    }\n    // Ensure container is clean (SDK's destroy should handle iframe, but good practice)\n    if (self.chartContainerElement) {\n        self.chartContainerElement.innerHTML = '';\n    }\n\n    let renderGraph;\n    if (window.EnergyChartSDK && typeof window.EnergyChartSDK.renderGraph === 'function') {\n        renderGraph = window.EnergyChartSDK.renderGraph;\n    } else {\n        console.error('EnergyChartSDK not loaded!');\n        if (self.chartContainerElement) {\n            self.chartContainerElement.innerHTML = '<div style=\"padding: 20px; text-align: center; color: red;\">EnergyChartSDK not loaded. Check widget configuration and browser console.</div>';\n        }\n        return;\n    }\n\n    const settings = self.ctx.settings || {};\n    const timeWindow = self.ctx.timeWindow;\n    // console.log('time window: ', timeWindow)\n\n    if (!timeWindow || typeof timeWindow.minTime === 'undefined' || typeof timeWindow.maxTime === 'undefined') {\n        console.error('Time window is not available or has incorrect format (missing minTime/maxTime).');\n        if (self.chartContainerElement) {\n             self.chartContainerElement.innerHTML = '<div style=\"padding: 20px; text-align: center; color: orange;\">Time window not available for chart.</div>';\n        }\n        return;\n    }\n\n    const gatewayId = centralId;\n    // It's good practice to ensure slaveId is a number, even if it should be from attributes\n    const startDate = formatDateToYMD(timeWindow.minTime, initialTimezone); // Use minTime & initialTimezone\n    const endDate = formatDateToYMD(timeWindow.maxTime, initialTimezone);   // Use maxTime & initialTimezone\n    const interval = determineInterval(timeWindow.minTime, timeWindow.maxTime);\n    const theme = settings.theme || 'light';\n    const apiBaseUrl = settings.apiBaseUrl || 'https://ingestion.myio-bas.com';\n    const timezone = initialTimezone; // Use the passed timezone\n\n    console.log(`Initializing chart with: gatewayId=${gatewayId}, slaveId=${slaveId}, startDate=${startDate}, endDate=${endDate}, interval=${interval}, theme=${theme}, apiBaseUrl=${apiBaseUrl}, timezone=${timezone}`);\n\n    self.chartInstance = renderGraph(self.chartContainerElement, {\n        gatewayId: gatewayId,\n        slaveId: slaveId,\n        startDate: startDate,\n        endDate: endDate,\n        interval: interval,\n        theme: theme,\n        timezone: timezone,\n        iframeBaseUrl: settings.iframeBaseUrl || 'https://graphs.ingestion.myio-bas.com', // Make iframeBaseUrl configurable\n        apiBaseUrl: apiBaseUrl,\n        chartPath: settings.chartPath || '/embed/energy-bar' // Make chartPath configurable\n    });\n\n    // Attach event listeners if SDK supports it\n    if (self.chartInstance && typeof self.chartInstance.on === 'function') {\n        self.chartInstance.on('drilldown', (data) => {\n            console.log('SDK Drilldown Event:', data);\n            // Example: Emit custom event for ThingsBoard dashboard actions\n            // self.ctx.actionsApi.handleWidgetAction({ actionIdentifier: 'customDrilldown', dataContext: data });\n        });\n        self.chartInstance.on('error', (errorData) => {\n            console.error('SDK Error Event:', errorData);\n             if (self.chartContainerElement) {\n                self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">Chart Error: ${errorData.message || 'Unknown error'}</div>`;\n            }\n        });\n    } else if(self.chartInstance) {\n        console.warn(\"EnergyChartSDK instance does not have an 'on' method for event listeners.\");\n    }\n}\n\nself.onTimewindowChanged = function(newTimeWindow) {\n    if (self.chartInstance && typeof self.chartInstance.changePeriod === 'function') {\n        const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        const startDate = formatDateToYMD(newTimeWindow.minTime, newTimezone); // Use minTime & newTimezone\n        const endDate = formatDateToYMD(newTimeWindow.maxTime, newTimezone);   // Use maxTime & newTimezone\n        const interval = determineInterval(newTimeWindow.minTime, newTimeWindow.maxTime);\n        \n        console.log(`Time window changed. Updating chart to: startDate=${startDate}, endDate=${endDate}, interval=${interval}, timezone=${newTimezone}`);\n        self.chartInstance.changePeriod(startDate, endDate, interval);\n    } else if (!self.chartInstance && self.ctx.$scope.slaveId !== undefined && self.ctx.$scope.centralId !== undefined) {\n        // If chart wasn't initialized (e.g. SDK loaded late, or initial error, but attributes ARE available)\n        const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        console.log('Time window changed, but chart not initialized. Attempting to initialize.');\n        initChart(self.ctx.$scope.slaveId, self.ctx.$scope.centralId, newTimezone);\n    } else {\n        console.warn(\"chartInstance.changePeriod is not a function or chart cannot be re-initialized. Time window change for chart ignored.\");\n        // Optionally re-initialize if attributes are available\n        // const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        // initChart(self.ctx.$scope.slaveId, self.ctx.$scope.centralId, newTimezone); \n    }\n};\n\n// Standard ThingsBoard widget lifecycle methods\nself.onDataUpdated = async function() { // Made async\n    console.log('[onDataUpdated] Fired. Time window:', self.ctx.timeWindow, 'Attributes ready:', self.attributesReady);\n    \n    if (!self.attributesReady) {\n        console.warn(\"[onDataUpdated] Attributes (centralId/slaveId) not ready. Aborting API call for sums. Waiting for onInit to complete or attributes to be available.\");\n        self.ctx.$scope.isLoading = false; // Not truly loading if we can't make the call\n        self.ctx.$scope.currentConsumption = self.ctx.$scope.currentConsumption === \"Carregando...\" ? \"Aguardando IDs...\" : self.ctx.$scope.currentConsumption;\n        self.ctx.$scope.lastConsumption = self.ctx.$scope.lastConsumption === \"Carregando...\" ? \"Aguardando IDs...\" : self.ctx.$scope.lastConsumption;\n        if (!self.ctx.$scope.errorMessage) { // Don't overwrite a more specific error from onInit\n            self.ctx.$scope.errorMessage = \"IDs do dispositivo (centralId/slaveId) ainda não disponíveis.\";\n        }\n        self.ctx.detectChanges();\n        return;\n    }\n    \n    self.ctx.$scope.isLoading = true;\n    // Preserve chart init error if any, but reset data-specific errors\n    let previousChartErrorMessage = self.ctx.$scope.errorMessage && self.ctx.$scope.errorMessage.startsWith(\"Erro nos atributos\") ? self.ctx.$scope.errorMessage : null;\n    self.ctx.$scope.errorMessage = null; \n\n    let currentVal = null;\n    let lastVal = null;\n    const decimals = self.ctx.settings.decimals !== undefined ? self.ctx.settings.decimals : 2;\n    const percentageDecimals = self.ctx.settings.percentageDecimals !== undefined ? self.ctx.settings.percentageDecimals : 0;\n    // Measurement unit can be updated from settings or later if API provides it (though current API doesn't)\n    self.ctx.$scope.measurement = self.ctx.settings.measurementUnit || \"kWh\";\n\n\n    if (!self.centralId || self.slaveId === undefined || self.slaveId === null) { // Check self.centralId and self.slaveId\n        self.ctx.$scope.errorMessage = \"centralId ou slaveId não definidos internamente. Verifique os atributos do dispositivo.\";\n        self.ctx.$scope.currentConsumption = \"Erro\";\n        self.ctx.$scope.lastConsumption = \"Erro\";\n        self.ctx.$scope.percentages = \"--\";\n        self.ctx.$scope.isLoading = false;\n        console.error(\"centralId or slaveId missing in scope for API call.\", {centralId: self.centralId, slaveId: self.slaveId});\n        self.ctx.detectChanges();\n        return;\n    }\n    \n    console.log(\"[onDataUpdated] Checking EnergyChartSDK availability:\");\n    console.log(\"[onDataUpdated] window.EnergyChartSDK exists:\", !!window.EnergyChartSDK);\n    if (window.EnergyChartSDK) {\n        console.log(\"[onDataUpdated] window.EnergyChartSDK.EnergyChart exists:\", !!window.EnergyChartSDK.EnergyChart);\n        if (window.EnergyChartSDK.EnergyChart) {\n            console.log(\"[onDataUpdated] window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum property value:\", window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum);\n            console.log(\"[onDataUpdated] typeof window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum:\", typeof window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum);\n        }\n    }\n\n    if (!window.EnergyChartSDK || !window.EnergyChartSDK.EnergyChart || typeof window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum !== 'function') {\n        console.log('SDK: ', window.EnergyChartSDK);\n        self.ctx.$scope.errorMessage = \"EnergyChartSDK ou EnergyChart.getEnergyComparisonSum não foi encontrada.\";\n        self.ctx.$scope.currentConsumption = \"Erro SDK\";\n        self.ctx.$scope.lastConsumption = \"Erro SDK\";\n        self.ctx.$scope.percentages = \"--\";\n        self.ctx.$scope.isLoading = false;\n        console.error(\"EnergyChartSDK or EnergyChart.getEnergyComparisonSum is not available.\");\n        self.ctx.detectChanges();\n        return;\n    }\n\n    try {\n        const params = {\n            gatewayId: self.centralId, // Use self.centralId\n            slaveId: self.slaveId,     // Use self.slaveId\n            // API expects ISO strings for startTs and endTs\n            startTs: new Date(self.ctx.timeWindow.minTime).toISOString(),\n            endTs: new Date(self.ctx.timeWindow.maxTime).toISOString(),\n            apiBaseUrl: self.ctx.$scope.apiBaseUrl \n        };\n        console.log(\"[onDataUpdated] Calling getEnergyComparisonSum with params:\", params);\n        const comparisonData = await window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum(params);\n        console.log(\"[onDataUpdated] Received data from getEnergyComparisonSum:\", comparisonData);\n\n        if (comparisonData && comparisonData.currentPeriod && comparisonData.previousPeriod) {\n            currentVal = parseFloat(comparisonData.currentPeriod.totalKwh);\n            lastVal = parseFloat(comparisonData.previousPeriod.totalKwh);\n\n            self.ctx.$scope.numericCurrentConsumption = currentVal;\n            self.ctx.$scope.currentConsumption = currentVal.toFixed(decimals);\n\n            self.ctx.$scope.numericLastConsumption = lastVal;\n            self.ctx.$scope.lastConsumption = lastVal.toFixed(decimals);\n            \n            // Potentially update measurement unit if API provided it, though this one doesn't\n            // self.ctx.$scope.measurement = comparisonData.units || self.ctx.$scope.measurement;\n\n        } else {\n            throw new Error(\"Formato de dados inválido recebido da API de comparação.\");\n        }\n\n    } catch (error) {\n        console.error(\"Erro ao buscar dados de comparação de energia:\", error);\n        self.ctx.$scope.errorMessage = error instanceof Error ? error.message : \"Falha ao buscar dados de consumo.\";\n        if (error.message && error.message.includes(\"API request failed with status 400\")) {\n             self.ctx.$scope.errorMessage = \"Erro na requisição à API (400): Verifique os parâmetros enviados.\";\n        } else if (error.message && error.message.includes(\"API request failed\")) {\n            self.ctx.$scope.errorMessage = \"Erro na API ao buscar dados de consumo.\";\n        }\n        self.ctx.$scope.currentConsumption = \"Erro\";\n        self.ctx.$scope.lastConsumption = \"Erro\";\n        self.ctx.$scope.percentages = \"--\";\n    } finally {\n        self.ctx.$scope.isLoading = false;\n    }\n    \n    // If there was a chart init error, make sure it's still displayed along with data errors\n    if (previousChartErrorMessage && self.ctx.$scope.errorMessage) {\n        self.ctx.$scope.errorMessage = previousChartErrorMessage + \" \" + self.ctx.$scope.errorMessage;\n    } else if (previousChartErrorMessage) {\n        self.ctx.$scope.errorMessage = previousChartErrorMessage;\n    }\n\n\n    if (currentVal !== null && !isNaN(currentVal) && lastVal !== null && !isNaN(lastVal)) {\n        if (lastVal !== 0) {\n            let percentageChange = ((currentVal - lastVal) / Math.abs(lastVal)) * 100; // Use Math.abs for denominator if it can be negative\n            self.ctx.$scope.percentages = percentageChange.toFixed(percentageDecimals);\n\n            if (percentageChange > 0.001) { \n                self.ctx.$scope.percentageType = 'increase';\n            } else if (percentageChange < -0.001) { \n                self.ctx.$scope.percentageType = 'decrease';\n            } else { \n                self.ctx.$scope.percentageType = 'neutral';\n                self.ctx.$scope.percentages = \"0\"; \n            }\n        } else if (currentVal > 0) { \n            self.ctx.$scope.percentages = \"∞\"; \n            self.ctx.$scope.percentageType = 'increase';\n        } else if (currentVal === 0 && lastVal === 0) {\n             self.ctx.$scope.percentages = \"0\";\n             self.ctx.$scope.percentageType = 'neutral';\n        } else {  // lastVal is 0 and currentVal is not positive (e.g. negative or zero)\n            self.ctx.$scope.percentages = \"--\"; \n            self.ctx.$scope.percentageType = 'neutral';\n        }\n    } else {\n        self.ctx.$scope.percentages = \"--\";\n        self.ctx.$scope.percentageType = 'neutral';\n        if (!self.ctx.$scope.errorMessage && (currentVal === null || lastVal === null || isNaN(currentVal) || isNaN(lastVal))) {\n             self.ctx.$scope.errorMessage = (self.ctx.$scope.errorMessage ? self.ctx.$scope.errorMessage + \" \" : \"\") + \"Dados insuficientes para cálculo percentual.\";\n        }\n    }\n    \n    // Update entity name if not already set and source becomes available\n    if (!self.ctx.$scope.entityName) {\n        if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.datasources && self.ctx.defaultSubscription.datasources.length > 0 && self.ctx.defaultSubscription.datasources[0].entityName) {\n            self.ctx.$scope.entityName = self.ctx.defaultSubscription.datasources[0].entityName;\n        } else if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.entityTitle) {\n             self.ctx.$scope.entityName = self.ctx.defaultSubscription.entityTitle;\n        }\n    }\n\n    // The original onDataUpdated simply called self.onTimewindowChanged.\n    // This implies the chart SDK component might need a refresh based on the current timewindow\n    // when new data arrives.\n    self.onTimewindowChanged(self.ctx.timeWindow);\n\n    self.ctx.detectChanges();\n};\n\nself.onDestroy = function() {\n    if (self.chartInstance && typeof self.chartInstance.destroy === 'function') {\n        self.chartInstance.destroy();\n        self.chartInstance = null;\n    }\n    if (self.chartContainerElement && self.chartContainerElement.parentNode) {\n        // Clean up the container DIV we created\n        self.chartContainerElement.parentNode.removeChild(self.chartContainerElement);\n        self.chartContainerElement = null;\n    }\n};\n",
      "settingsSchema" : "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"type\": \"string\",\r\n                \"title\": \"Título do Card\"\r\n            },\r\n            \"measurement\":{\r\n                \"type\":\"string\",\r\n                \"title\":\"Tipo de medição\"\r\n            }\r\n            \r\n        },\r\n        \"required\": [\"title\"]\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n        \"measurement\"\r\n        \r\n        \r\n    ]\r\n}",
      "dataKeySettingsSchema" : "{}",
      "latestDataKeySettingsSchema" : "{}",
      "settingsDirective" : "",
      "dataKeySettingsDirective" : "",
      "latestDataKeySettingsDirective" : "tb-value-card-widget-settings",
      "hasBasicMode" : true,
      "basicModeDirective" : "",
      "defaultConfig" : "{\"showTitle\":false,\"backgroundColor\":\"rgba(0, 0, 0, 0)\",\"color\":\"rgba(33, 186, 79, 0.87)\",\"padding\":\"0px\",\"settings\":{\"title\":\"Título do Card\"},\"title\":\"Somatório do Período\",\"dropShadow\":true,\"enableFullscreen\":false,\"titleStyle\":null,\"mobileHeight\":null,\"configMode\":\"advanced\",\"actions\":{},\"showTitleIcon\":false,\"titleIcon\":\"thermostat\",\"iconColor\":\"#1F6BDD\",\"useDashboardTimewindow\":false,\"displayTimewindow\":false,\"titleFont\":{\"size\":16,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"500\",\"style\":\"normal\",\"lineHeight\":\"24px\"},\"titleColor\":\"rgba(0, 0, 0, 0.87)\",\"titleTooltip\":\"\",\"widgetStyle\":{},\"widgetCss\":\"\",\"pageSize\":1024,\"units\":\"\",\"decimals\":null,\"noDataDisplayMessage\":\"\",\"timewindowStyle\":{\"showIcon\":false,\"iconSize\":\"24px\",\"icon\":null,\"iconPosition\":\"left\",\"font\":{\"size\":12,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"400\",\"style\":\"normal\",\"lineHeight\":\"16px\"},\"color\":\"rgba(0, 0, 0, 0.38)\",\"displayTypePrefix\":true},\"margin\":\"0px\",\"borderRadius\":\"0px\",\"iconSize\":\"0px\",\"timewindow\":{\"realtime\":{\"timewindowMs\":86400000}},\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.0049099568976449515,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin 2\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.29530602333210765,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"}],\"alarmFilterConfig\":{\"statusList\":[\"ACTIVE\"]}}],\"enableDataExport\":false}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "9fa00650-338f-11f0-8cbd-2b87fdb093e1"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}