{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "somat_rio_do_per_odo",
    "name" : "Somatório do Período",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "timeseries",
      "sizeX" : 8,
      "sizeY" : 5.5,
      "resources" : [ {
        "url" : "https://graphs.ingestion.myio-bas.com/sdk/energy-chart-sdk.umd.js"
      } ],
      "templateHtml" : "<mat-card class=\"myio-sum-comparison-card\">\n\n    <!-- Header: Icon + Percentage Change -->\n    <div class=\"myio-card-top-header\">\n        <div class=\"myio-lightning-icon-container\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28px\" height=\"28px\" viewBox=\"0 -880 960 960\" fill=\"var(--tb-primary-700, #FFC107)\"> <!-- Adjusted fill -->\n                <path d=\"m456-200 174-340H510v-220L330-420h126v220Zm24 120q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5-156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z\"/>\n            </svg>\n        </div>\n        <div *ngIf=\"!isLoading && !errorMessage\" class=\"myio-percentage-change\"\n             [ngStyle]=\"{\n                 'color': percentageType === 'increase' ? 'var(--tb-danger-500, #D32F2F)' : (percentageType === 'decrease' ? 'var(--tb-success-500, #388E3C)' : 'inherit')\n             }\">\n            <span class=\"myio-percentage-value\">{{percentages}}%</span>\n            <svg *ngIf=\"percentageType === 'increase'\" class=\"myio-percentage-arrow\" xmlns=\"http://www.w3.org/2000/svg\" height=\"22px\" viewBox=\"0 -960 960 960\" width=\"22px\">\n                <path d=\"M440-240v-368L296-464l-56-56 240-240 240 240-56 56-144-144v368h-80Z\"/>\n            </svg>\n            <svg *ngIf=\"percentageType === 'decrease'\" class=\"myio-percentage-arrow\" xmlns=\"http://www.w3.org/2000/svg\" height=\"22px\" viewBox=\"0 -960 960 960\" width=\"22px\">\n                <path d=\"M480-240 240-480l56-56 144 144v-368h80v368l144-144 56 56-240 240Z\"/>\n            </svg>\n        </div>\n    </div>\n\n    <!-- Main Content: Title, Current Consumption -->\n    <mat-card-content class=\"myio-main-content\">\n        <div *ngIf=\"isLoading\" class=\"myio-loading-message\">Carregando...</div>\n        <div *ngIf=\"errorMessage && !isLoading\" class=\"myio-error-message\">{{errorMessage}}</div>\n\n        <div *ngIf=\"!isLoading && !errorMessage\">\n            <div class=\"myio-widget-title\">{{title}} {{entityName}}</div>\n            <div class=\"myio-current-consumption\">\n                <span>{{currentConsumption}}</span>\n                <span class=\"myio-measurement-unit\">{{measurement}}</span>\n            </div>\n        </div>\n    </mat-card-content>\n\n    <!-- Footer Content: Last Period -->\n    <mat-card-footer *ngIf=\"!isLoading && !errorMessage\" class=\"myio-footer-content\">\n        <div class=\"myio-last-period\">\n            <span class=\"myio-last-period-label\">Último periodo:</span>\n            <span class=\"myio-last-period-value\">\n                {{lastConsumption}}\n                <span class=\"myio-measurement-unit-small\">{{measurement}}</span>\n            </span>\n        </div>\n    </mat-card-footer>\n</mat-card>",
      "templateCss" : "/* Overall Card Styling */\n.myio-sum-comparison-card {\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    height: 100%;\n    padding: 12px; /* Reduced padding */\n    box-sizing: border-box;\n    background-color: var(--tb-service-background, #fff); /* Use theme variable */\n    border-radius: var(--tb-border-radius, 4px);\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05), 0 2px 8px rgba(0, 0, 0, 0.05); /* Softer shadow */\n}\n\n/* Top Header: Icon + Percentage */\n.myio-card-top-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 8px;\n}\n\n.myio-lightning-icon-container svg {\n    display: block; /* Helps with alignment */\n}\n\n.myio-percentage-change {\n    display: flex;\n    align-items: center;\n    font-size: 1.1rem; /* Slightly larger percentage */\n    font-weight: 600;\n}\n\n.myio-percentage-value {\n    margin-right: 4px;\n}\n\n.myio-percentage-arrow {\n    fill: currentColor; /* Inherits color from parent's ngStyle */\n}\n\n/* Main Content: Title + Current Consumption */\n.myio-main-content {\n    text-align: center;\n    padding: 8px 0; /* Adjust padding */\n    flex-grow: 1; /* Allow this section to grow */\n    display: flex;\n    flex-direction: column;\n    justify-content: center; /* Center content vertically if it doesn't fill space */\n}\n\n.myio-widget-title {\n    font-size: 0.9rem;\n    color: var(--tb-text-color-secondary, #757575); /* Use theme variable */\n    margin-bottom: 4px;\n    display: block;\n    line-height: 1.3;\n}\n\n.myio-current-consumption {\n    font-size: 2.2rem; /* Prominent current consumption */\n    font-weight: 500; /* Slightly less bold than 600 for balance */\n    color: var(--tb-text-color, #212121); /* Use theme variable */\n    line-height: 1.1;\n    margin-bottom: 8px;\n}\n\n.myio-current-consumption .myio-measurement-unit {\n    font-size: 1.2rem; /* Smaller unit next to the large value */\n    font-weight: 400;\n    color: var(--tb-text-color-secondary, #757575);\n    margin-left: 4px;\n}\n\n/* Footer: Last Period */\n.myio-footer-content {\n    padding: 8px 0 0; /* Padding top only */\n    text-align: center;\n    border-top: 1px solid var(--tb-border-color, rgba(0,0,0,0.12)); /* Subtle separator */\n}\n\n.myio-last-period {\n    font-size: 0.85rem;\n    color: var(--tb-text-color-secondary, #757575);\n}\n\n.myio-last-period-label {\n    margin-right: 5px;\n}\n\n.myio-last-period-value {\n    font-weight: 500;\n    color: var(--tb-text-color, #515151); /* Slightly less prominent than current */\n}\n\n.myio-last-period-value .myio-measurement-unit-small {\n    font-size: 0.75rem;\n    font-weight: 400;\n    margin-left: 2px;\n}\n\n/* Loading and Error States */\n.myio-loading-message,\n.myio-error-message {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 100%;\n    font-size: 1rem;\n    color: var(--tb-text-color-secondary, #757575);\n}\n\n.myio-error-message {\n    color: var(--tb-danger-500, #D32F2F);\n    padding: 10px;\n    text-align: center;\n    white-space: normal; /* Allow error messages to wrap */\n}\n\n/* Remove default mat-card paddings if they conflict */\n:host ::ng-deep .mat-card-header .mat-card-header-text {\n    margin: 0;\n}\n\n:host ::ng-deep mat-card-content {\n    padding: 0; /* Reset padding if we manage it with our classes */\n}\n\n:host ::ng-deep mat-card-footer {\n    padding: 0; /* Reset padding */\n    margin: 0; /* Reset margin */\n}\n\n/* Styles for the old class names to avoid breaking anything if they were used elsewhere, though the HTML structure changed */\n.myio-comparativeConsumption-card-header { }\n.myio-header-percentages { }\n.myio-icon { }\n.myio-comparativeConsumption-card-content { }\n.card-content { }\n.content-telemetry-title { }\n.content-telemetry-consumption { }\n.content-latest-telemetry-title { }\n.content-latest-telemetry-consumption { }\n.myio-comparativeConsumption-card-footer { }",
      "controllerScript" : "// Helper function to format a millisecond timestamp to YYYY-MM-DD\nfunction formatDateToYMD(timestampMs, tzIdentifier) {\n    const date = new Date(timestampMs);\n    const formatter = new Intl.DateTimeFormat('default', {\n        timeZone: tzIdentifier,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit'\n    });\n    \n    const parts = formatter.formatToParts(date);\n    const year = parts.find(p => p.type === 'year').value;\n    const month = parts.find(p => p.type === 'month').value;\n    const day = parts.find(p => p.type === 'day').value;\n    \n    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\n}\n\n// Helper function to determine a suitable interval based on time duration\nfunction determineInterval(startTimeMs, endTimeMs) {\n    const durationMs = endTimeMs - startTimeMs;\n    const durationDays = durationMs / (1000 * 60 * 60 * 24);\n\n    console.log('Duration days: ', durationDays);\n    if (durationDays > 2) { // More than 2 days\n        return '1 month';\n    } else { // 2 days or less\n        return '1 day';\n    }\n}\n\nself.onInit = async function() {\n    // Initialize scope variables\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null;\n    self.ctx.$scope.title = self.ctx.settings.title || \"Consumo Energético\";\n    self.ctx.$scope.entityName = \"\";\n    self.ctx.$scope.percentages = \"--\";\n    self.ctx.$scope.percentageType = 'neutral';\n    self.ctx.$scope.currentConsumption = \"Carregando...\";\n    self.ctx.$scope.lastConsumption = \"Carregando...\";\n    self.ctx.$scope.measurement = self.ctx.settings.measurementUnit || \"kWh\";\n    self.ctx.$scope.numericCurrentConsumption = null;\n    self.ctx.$scope.numericLastConsumption = null;\n    self.ctx.$scope.apiBaseUrl = self.ctx.settings.apiBaseUrl || 'https://ingestion.myio-bas.com';\n\n    // Widget's internal state for attributes\n    self.centralId = null;\n    self.slaveId = null;\n    self.attributesReady = false;\n    // Create a deferred promise for attribute readiness\n    let resolveAttributesPromise;\n    self.attributesPromise = new Promise(resolve => {\n        resolveAttributesPromise = resolve;\n    });\n\n    // Attempt to get entity name\n    if (self.ctx.aliasController && typeof self.ctx.aliasController.getEntity === 'function') {\n        const entity = self.ctx.aliasController.getEntity();\n        if (entity && entity.name) self.ctx.$scope.entityName = entity.name;\n    } else if (self.ctx.aliasController && self.ctx.aliasController.entity && self.ctx.aliasController.entity.name) {\n        self.ctx.$scope.entityName = self.ctx.aliasController.entity.name;\n    } else if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.entityTitle) {\n        self.ctx.$scope.entityName = self.ctx.defaultSubscription.entityTitle;\n    }\n\n    self.chartInstance = null;\n    self.chartContainerElement = document.createElement('div');\n    self.chartContainerElement.style.width = '100%';\n    self.chartContainerElement.style.height = '100%';\n    self.chartContainerElement.style.minHeight = '300px';\n    self.ctx.$container.append(self.chartContainerElement);\n\n    try {\n        const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n        let entityId, entityType;\n\n        if (self.ctx.defaultSubscription && self.ctx.defaultSubscription.datasources && self.ctx.defaultSubscription.datasources.length > 0) {\n            const firstDatasource = self.ctx.defaultSubscription.datasources[0];\n            entityId = firstDatasource.entityId;\n            entityType = firstDatasource.entityType;\n            if (!self.ctx.$scope.entityName && firstDatasource.entityName) {\n                self.ctx.$scope.entityName = firstDatasource.entityName;\n            }\n        }\n\n        if (!entityId || !entityType) {\n            console.error(\"sum-with-comparison: EntityId/EntityType not found from datasources.\");\n            self.ctx.$scope.errorMessage = \"Contexto do dispositivo não configurado.\";\n            throw new Error(\"Missing entity context for attribute fetching.\"); // Throw to be caught by catch block\n        }\n\n        const deviceAttributes = await attributeService.getEntityAttributes(\n            { id: entityId, entityType: entityType },\n            'SERVER_SCOPE',\n            ['centralId', 'slaveId']\n        ).toPromise();\n\n        const centralIdAttr = deviceAttributes.find(attribute => attribute.key === 'centralId');\n        const slaveIdAttr = deviceAttributes.find(attribute => attribute.key === 'slaveId');\n\n        const centralIdValue = centralIdAttr ? centralIdAttr.value : null;\n        // Assuming slaveId value from attribute can be number or string representing a number\n        const slaveIdValue = slaveIdAttr ? (typeof slaveIdAttr.value === 'string' ? parseInt(slaveIdAttr.value) : slaveIdAttr.value) : null;\n\n\n        if (!centralIdValue || slaveIdValue === null || typeof slaveIdValue !== 'number' || isNaN(slaveIdValue)) {\n            console.error(`sum-with-comparison: Missing or invalid device attributes: centralId='${centralIdValue}', slaveId='${slaveIdValue}'.`);\n            self.ctx.$scope.errorMessage = \"Atributos do dispositivo (centralId/slaveId) ausentes ou inválidos.\";\n            self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">${self.ctx.$scope.errorMessage}</div>`;\n            // Let isLoading be handled by onDataUpdated or finally, attributesReady remains false\n        } else {\n            self.centralId = centralIdValue;\n            self.slaveId = slaveIdValue;\n            self.ctx.$scope.centralId = self.centralId; // For potential direct template use\n            self.ctx.$scope.slaveId = self.slaveId;     // For potential direct template use\n            self.attributesReady = true;\n            console.log(`sum-with-comparison: Attributes fetched: centralId=${self.centralId}, slaveId=${self.slaveId}`);\n            initChart(self.slaveId, self.centralId, self.ctx.timeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo');\n        }\n    } catch (e) {\n        console.error('sum-with-comparison: Error during onInit:', e);\n        self.ctx.$scope.errorMessage = e.message || \"Erro durante a inicialização do widget.\";\n        if (self.chartContainerElement && !self.chartContainerElement.innerHTML.includes('color: red')) { // Avoid overwriting specific attribute error message\n             self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">${self.ctx.$scope.errorMessage}</div>`;\n        }\n        self.attributesReady = false;\n    } finally {\n        //isLoading is managed by onDataUpdated primarily to reflect data loading status\n        //If onInit fails critically AND onDataUpdated doesn't run, isLoading might remain true.\n        //Setting it here ensures it's false if init fails before onDataUpdated has a chance.\n        if (!self.attributesReady) {\n             self.ctx.$scope.isLoading = false;\n        }\n        console.log(`sum-with-comparison: onInit finished. attributesReady: ${self.attributesReady}`);\n        resolveAttributesPromise(); // Resolve the promise regardless of success/failure of attribute fetching\n        self.ctx.detectChanges();\n    }\n};\n\nfunction initChart(slaveId, centralId, initialTimezone) {\n    // Destroy previous instance if it exists\n    if (self.chartInstance && typeof self.chartInstance.destroy === 'function') {\n        self.chartInstance.destroy();\n        self.chartInstance = null;\n    }\n    // Ensure container is clean (SDK's destroy should handle iframe, but good practice)\n    if (self.chartContainerElement) {\n        self.chartContainerElement.innerHTML = '';\n    }\n\n    let renderGraph;\n    if (window.EnergyChartSDK && typeof window.EnergyChartSDK.renderGraph === 'function') {\n        renderGraph = window.EnergyChartSDK.renderGraph;\n    } else {\n        console.error('EnergyChartSDK not loaded!');\n        if (self.chartContainerElement) {\n            self.chartContainerElement.innerHTML = '<div style=\"padding: 20px; text-align: center; color: red;\">EnergyChartSDK not loaded. Check widget configuration and browser console.</div>';\n        }\n        return;\n    }\n\n    const settings = self.ctx.settings || {};\n    const timeWindow = self.ctx.timeWindow;\n    // console.log('time window: ', timeWindow)\n\n    if (!timeWindow || typeof timeWindow.minTime === 'undefined' || typeof timeWindow.maxTime === 'undefined') {\n        console.error('Time window is not available or has incorrect format (missing minTime/maxTime).');\n        if (self.chartContainerElement) {\n             self.chartContainerElement.innerHTML = '<div style=\"padding: 20px; text-align: center; color: orange;\">Time window not available for chart.</div>';\n        }\n        return;\n    }\n\n    const gatewayId = centralId;\n    // It's good practice to ensure slaveId is a number, even if it should be from attributes\n    const startDate = formatDateToYMD(timeWindow.minTime, initialTimezone); // Use minTime & initialTimezone\n    const endDate = formatDateToYMD(timeWindow.maxTime, initialTimezone);   // Use maxTime & initialTimezone\n    const interval = determineInterval(timeWindow.minTime, timeWindow.maxTime);\n    const theme = settings.theme || 'light';\n    const apiBaseUrl = settings.apiBaseUrl || 'https://ingestion.myio-bas.com';\n    const timezone = initialTimezone; // Use the passed timezone\n\n    console.log(`Initializing chart with: gatewayId=${gatewayId}, slaveId=${slaveId}, startDate=${startDate}, endDate=${endDate}, interval=${interval}, theme=${theme}, apiBaseUrl=${apiBaseUrl}, timezone=${timezone}`);\n\n    self.chartInstance = renderGraph(self.chartContainerElement, {\n        gatewayId: gatewayId,\n        slaveId: slaveId,\n        startDate: startDate,\n        endDate: endDate,\n        interval: interval,\n        theme: theme,\n        timezone: timezone,\n        iframeBaseUrl: settings.iframeBaseUrl || 'https://graphs.ingestion.myio-bas.com', // Make iframeBaseUrl configurable\n        apiBaseUrl: apiBaseUrl,\n        chartPath: settings.chartPath || '/embed/energy-bar' // Make chartPath configurable\n    });\n\n    // Attach event listeners if SDK supports it\n    if (self.chartInstance && typeof self.chartInstance.on === 'function') {\n        self.chartInstance.on('drilldown', (data) => {\n            console.log('SDK Drilldown Event:', data);\n            // Example: Emit custom event for ThingsBoard dashboard actions\n            // self.ctx.actionsApi.handleWidgetAction({ actionIdentifier: 'customDrilldown', dataContext: data });\n        });\n        self.chartInstance.on('error', (errorData) => {\n            console.error('SDK Error Event:', errorData);\n             if (self.chartContainerElement) {\n                self.chartContainerElement.innerHTML = `<div style=\"padding: 20px; text-align: center; color: red;\">Chart Error: ${errorData.message || 'Unknown error'}</div>`;\n            }\n        });\n    } else if(self.chartInstance) {\n        console.warn(\"EnergyChartSDK instance does not have an 'on' method for event listeners.\");\n    }\n}\n\nself.onTimewindowChanged = async function(newTimeWindow) {\n    if (self.attributesPromise) { // Ensure onInit has started\n        await self.attributesPromise;\n    }\n    if (!self.attributesReady) {\n        console.warn(\"[onTimewindowChanged] Attributes not ready, cannot update chart period effectively.\");\n        // Optionally, display a message or simply don't attempt to update chart if IDs are missing.\n        return; // Or proceed cautiously if chart doesn't strictly need centralId/slaveId for period change alone\n    }\n\n    if (self.chartInstance && typeof self.chartInstance.changePeriod === 'function') {\n        const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        const startDate = formatDateToYMD(newTimeWindow.minTime, newTimezone); // Use minTime & newTimezone\n        const endDate = formatDateToYMD(newTimeWindow.maxTime, newTimezone);   // Use maxTime & newTimezone\n        const interval = determineInterval(newTimeWindow.minTime, newTimeWindow.maxTime);\n        \n        console.log(`Time window changed. Updating chart to: startDate=${startDate}, endDate=${endDate}, interval=${interval}, timezone=${newTimezone}`);\n        self.chartInstance.changePeriod(startDate, endDate, interval);\n    } else if (!self.chartInstance && self.attributesReady) { // Check attributesReady here too\n        // If chart wasn't initialized (e.g. SDK loaded late, or initial error, but attributes ARE available)\n        const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        console.log('Time window changed, but chart not initialized. Attempting to initialize with stored attributes.');\n        initChart(self.slaveId, self.centralId, newTimezone);\n    } else {\n        console.warn(\"chartInstance.changePeriod is not a function or chart cannot be re-initialized. Time window change for chart ignored.\");\n        // Optionally re-initialize if attributes are available\n        // const newTimezone = newTimeWindow.timezone || self.ctx.settings.timezone || 'America/Sao_Paulo';\n        // initChart(self.ctx.$scope.slaveId, self.ctx.$scope.centralId, newTimezone); \n    }\n};\n\nself.onDataUpdated = async function() {\n    if (self.attributesPromise) { // Ensure onInit has at least started setting up the promise\n        await self.attributesPromise; // Wait for onInit to complete its attempt to get attributes\n    }\n\n    console.log(`[onDataUpdated] Fired. Attributes ready: ${self.attributesReady}`);\n\n    if (!self.attributesReady) {\n        self.ctx.$scope.isLoading = false;\n        if (!self.ctx.$scope.errorMessage) { // Don't overwrite a more specific error from onInit\n            self.ctx.$scope.currentConsumption = \"Aguardando IDs...\";\n            self.ctx.$scope.lastConsumption = \"Aguardando IDs...\";\n            self.ctx.$scope.errorMessage = \"IDs do dispositivo (centralId/slaveId) não disponíveis.\";\n        }\n        self.ctx.detectChanges();\n        return;\n    }\n\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null; // Clear previous data errors\n\n    let currentVal = null;\n    let lastVal = null;\n    const decimals = self.ctx.settings.decimals !== undefined ? self.ctx.settings.decimals : 2;\n    const percentageDecimals = self.ctx.settings.percentageDecimals !== undefined ? self.ctx.settings.percentageDecimals : 0;\n    self.ctx.$scope.measurement = self.ctx.settings.measurementUnit || \"kWh\";\n\n    try {\n        if (!window.EnergyChartSDK || !window.EnergyChartSDK.EnergyChart || typeof window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum !== 'function') {\n            throw new Error(\"SDK para busca de dados de consumo (getEnergyComparisonSum) não encontrado ou inválido.\");\n        }\n\n        const params = {\n            gatewayId: self.centralId,\n            slaveId: self.slaveId,\n            startTs: new Date(self.ctx.timeWindow.minTime).toISOString(),\n            endTs: new Date(self.ctx.timeWindow.maxTime).toISOString(),\n            apiBaseUrl: self.ctx.$scope.apiBaseUrl\n        };\n        // console.log(\"[onDataUpdated] Calling getEnergyComparisonSum with params:\", params); // Optional: uncomment for debugging\n        const comparisonData = await window.EnergyChartSDK.EnergyChart.getEnergyComparisonSum(params);\n        // console.log(\"[onDataUpdated] Received data from getEnergyComparisonSum:\", comparisonData); // Optional: uncomment for debugging\n\n        if (comparisonData && comparisonData.currentPeriod && typeof comparisonData.currentPeriod.totalKwh === 'number' &&\n            comparisonData.previousPeriod && typeof comparisonData.previousPeriod.totalKwh === 'number') {\n            currentVal = comparisonData.currentPeriod.totalKwh;\n            lastVal = comparisonData.previousPeriod.totalKwh;\n\n            self.ctx.$scope.numericCurrentConsumption = currentVal;\n            self.ctx.$scope.currentConsumption = currentVal.toFixed(decimals);\n            self.ctx.$scope.numericLastConsumption = lastVal;\n            self.ctx.$scope.lastConsumption = lastVal.toFixed(decimals);\n        } else {\n            throw new Error(\"Dados de consumo recebidos da API em formato inválido.\");\n        }\n    } catch (error) {\n        console.error(\"sum-with-comparison: Erro ao buscar dados de comparação de energia:\", error);\n        self.ctx.$scope.errorMessage = error.message || \"Falha ao buscar dados de consumo.\";\n        self.ctx.$scope.currentConsumption = \"Erro\";\n        self.ctx.$scope.lastConsumption = \"Erro\";\n        self.ctx.$scope.percentages = \"--\";\n        self.ctx.$scope.percentageType = 'neutral';\n    } finally {\n        self.ctx.$scope.isLoading = false;\n    }\n\n    // Percentage calculation (remains the same as it's core logic)\n    if (currentVal !== null && lastVal !== null) { // Ensure values were successfully fetched and parsed\n        if (lastVal !== 0) {\n            let percentageChange = ((currentVal - lastVal) / Math.abs(lastVal)) * 100;\n            self.ctx.$scope.percentages = percentageChange.toFixed(percentageDecimals);\n            if (percentageChange > 0.001) {\n                self.ctx.$scope.percentageType = 'increase';\n            } else if (percentageChange < -0.001) {\n                self.ctx.$scope.percentageType = 'decrease';\n            } else {\n                self.ctx.$scope.percentageType = 'neutral';\n                self.ctx.$scope.percentages = \"0\";\n            }\n        } else if (currentVal > 0) {\n            self.ctx.$scope.percentages = \"∞\";\n            self.ctx.$scope.percentageType = 'increase';\n        } else if (currentVal === 0 && lastVal === 0) {\n            self.ctx.$scope.percentages = \"0\";\n            self.ctx.$scope.percentageType = 'neutral';\n        } else {\n            self.ctx.$scope.percentages = \"--\";\n            self.ctx.$scope.percentageType = 'neutral';\n        }\n    } else if (!self.ctx.$scope.errorMessage) { // If no specific API error, but values are null\n        self.ctx.$scope.percentages = \"--\";\n        self.ctx.$scope.percentageType = 'neutral';\n        // Only set this if no other error message is present from the API call\n        // self.ctx.$scope.errorMessage = \"Dados insuficientes para cálculo percentual.\";\n    }\n\n    self.ctx.detectChanges();\n};\n\nself.onDestroy = function() {\n    if (self.chartInstance && typeof self.chartInstance.destroy === 'function') {\n        self.chartInstance.destroy();\n        self.chartInstance = null;\n    }\n    if (self.chartContainerElement && self.chartContainerElement.parentNode) {\n        // Clean up the container DIV we created\n        self.chartContainerElement.parentNode.removeChild(self.chartContainerElement);\n        self.chartContainerElement = null;\n    }\n};\n",
      "settingsSchema" : "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"type\": \"string\",\r\n                \"title\": \"Título do Card\"\r\n            },\r\n            \"measurement\":{\r\n                \"type\":\"string\",\r\n                \"title\":\"Tipo de medição\"\r\n            }\r\n            \r\n        },\r\n        \"required\": [\"title\"]\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n        \"measurement\"\r\n        \r\n        \r\n    ]\r\n}",
      "dataKeySettingsSchema" : "{}",
      "latestDataKeySettingsSchema" : "{}",
      "settingsDirective" : "",
      "dataKeySettingsDirective" : "",
      "latestDataKeySettingsDirective" : "tb-value-card-widget-settings",
      "hasBasicMode" : true,
      "basicModeDirective" : "",
      "defaultConfig" : "{\"showTitle\":false,\"backgroundColor\":\"rgba(0, 0, 0, 0)\",\"color\":\"rgba(33, 186, 79, 0.87)\",\"padding\":\"0px\",\"settings\":{\"title\":\"Título do Card\"},\"title\":\"Somatório do Período\",\"dropShadow\":true,\"enableFullscreen\":false,\"titleStyle\":null,\"mobileHeight\":null,\"configMode\":\"advanced\",\"actions\":{},\"showTitleIcon\":false,\"titleIcon\":\"thermostat\",\"iconColor\":\"#1F6BDD\",\"useDashboardTimewindow\":false,\"displayTimewindow\":false,\"titleFont\":{\"size\":16,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"500\",\"style\":\"normal\",\"lineHeight\":\"24px\"},\"titleColor\":\"rgba(0, 0, 0, 0.87)\",\"titleTooltip\":\"\",\"widgetStyle\":{},\"widgetCss\":\"\",\"pageSize\":1024,\"units\":\"\",\"decimals\":null,\"noDataDisplayMessage\":\"\",\"timewindowStyle\":{\"showIcon\":false,\"iconSize\":\"24px\",\"icon\":null,\"iconPosition\":\"left\",\"font\":{\"size\":12,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"400\",\"style\":\"normal\",\"lineHeight\":\"16px\"},\"color\":\"rgba(0, 0, 0, 0.38)\",\"displayTypePrefix\":true},\"margin\":\"0px\",\"borderRadius\":\"0px\",\"iconSize\":\"0px\",\"timewindow\":{\"realtime\":{\"timewindowMs\":86400000}},\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.0049099568976449515,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin 2\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.29530602333210765,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"}],\"alarmFilterConfig\":{\"statusList\":[\"ACTIVE\"]}}],\"enableDataExport\":false}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "9fa00650-338f-11f0-8cbd-2b87fdb093e1"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}