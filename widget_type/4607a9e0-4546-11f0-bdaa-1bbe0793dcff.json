{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "agendamento_simples_temp",
    "name" : "Agendamento_simples_Temp",
    "deprecated" : false,
    "image" : "tb-image;/api/images/tenant/Screenshot from 2024-04-11 20-14-06.png",
    "description" : null,
    "descriptor" : {
      "type" : "latest",
      "sizeX" : 8,
      "sizeY" : 6,
      "resources" : [ ],
      "templateHtml" : "<div id=\"main\" class=\"loading\" *ngIf=\"loading\">\n    <mat-progress-spinner mode=\"indeterminate\" color=\"accent\" style=\"width: 32px;\">\n    </mat-progress-spinner>\n</div>\n\n<div id=\"main\" *ngIf=\"!loading\">\n    <div *ngFor=\"let schedule of schedules; let i = index\" class=\"schedule-row\" [ngClass]=\"{ 'has-error': schedule.errors.overlap }\">\n        <fieldset id=\"cloneable-fieldset\">\n            <legend id=\"titulo\">{{entityName}}</legend>\n            <fieldset class=\"form-control\">\n                <legend for=\"Inicio\">Início</legend>\n                <input type=\"time\" name=\"Hora\"\n                    [(ngModel)]=\"schedule.startTime\"\n                    id=\"time\"\n                    required />\n                <span class=\"error-message\" *ngIf=\"schedule.errors.startTime\">{{ schedule.errors.startTime }}</span>\n            </fieldset>\n\n            <fieldset class=\"form-control\">\n                <legend for=\"Inicio\">Término</legend>\n                <input type=\"time\" name=\"Hora\"\n                    [(ngModel)]=\"schedule.endTime\"\n                    id=\"time\"\n                    required />\n                <span class=\"error-message\" *ngIf=\"schedule.errors.endTime\">{{ schedule.errors.endTime }}</span>\n            </fieldset>\n\n            <fieldset class=\"form-control\">\n                <legend>Dias:</legend>\n                <div class=\"selectDays\">\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.mon\"\n                            type=\"checkbox\" id=\"segunda\"\n                            name=\"daysWeek[]\" value=\"Segunda\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"segunda\">Segunda</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.tue\"\n                            type=\"checkbox\" id=\"terca\"\n                            name=\"daysWeek[]\" value=\"Terça\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"terca\">Terça</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.wed\"\n                            type=\"checkbox\" id=\"quarta\"\n                            name=\"daysWeek[]\" value=\"Quarta\"\n                            class=\"custom-checkbox\">\n                        <label for=\"quarta\">Quarta</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.thu\"\n                            type=\"checkbox\" id=\"quinta\"\n                            name=\"daysWeek[]\" value=\"Quinta\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"quinta\">Quinta</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.fri\"\n                            type=\"checkbox\" id=\"sexta\"\n                            name=\"daysWeek[]\" value=\"Sexta\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"sexta\">Sexta</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.sat\"\n                            type=\"checkbox\" id=\"sabado\"\n                            name=\"daysWeek[]\" value=\"Sábado\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"sabado\">Sábado</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.daysWeek.sun\"\n                            type=\"checkbox\" id=\"domingo\"\n                            name=\"daysWeek[]\" value=\"Domingo\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"domingo\">Domingo</label>\n                    </div>\n                    <div class=\"checkboxDays\">\n                        <input\n                            [(ngModel)]=\"schedule.holiday\"\n                            type=\"checkbox\" id=\"feriado\"\n                            name=\"Feriado\" value=\"Feriado\"\n                            class=\"custom-checkbox\">\n\n                        <label for=\"segunda\">Feriado</label>\n                    </div>\n                </div>\n                <span class=\"error-message\" *ngIf=\"schedule.errors.daysWeek\">{{ schedule.errors.daysWeek }}</span>\n            </fieldset>\n\n            <fieldset class=\"form-control\">\n                <legend>Setpoint (°C):</legend>\n                <input type=\"number\" name=\"setpoint\"\n                    [(ngModel)]=\"schedule.setpoint\"\n                    id=\"setpoint-{{i}}\"\n                    min=\"16\" max=\"26\" step=\"1\"\n                    required />\n                <span class=\"error-message\" *ngIf=\"schedule.errors.setpoint\">{{ schedule.errors.setpoint }}</span>\n            </fieldset>\n\n            <span class=\"error-message overlap-error\" *ngIf=\"schedule.errors.overlap\">{{ schedule.errors.overlap }}</span>\n\n            <button type=\"submit\" (click)=\"remove(schedule)\">\n                Remover\n            </button>\n\n        </fieldset>\n    </div>\n\n    <div class=\"divButtons\">\n        <button type=\"submit\" (click)=\"addSchedule()\">+\n            Intervalo</button>\n        <button type=\"submit\"\n            (click)=\"submit()\"\n            [disabled]=\"loading\">Salvar</button>\n    </div>\n</div>\n\n<style>\n    .error-message {\n        color: red;\n        font-size: 0.8em;\n        display: block; /* Or inline-block */\n    }\n    .schedule-row.has-error {\n      /* Optional: visually indicate rows with overlap errors */\n      /* border: 1px solid red; */\n      /* background-color: #ffebeb; */\n    }\n    .days-week label {\n        margin-right: 5px;\n    }\n    /* Add other styles as needed for layout */\n    .schedule-row > div {\n        margin-bottom: 10px;\n    }\n\n    /* Custom styles for inputs to match dark theme */\n    .form-control input[type=\"number\"] { /* Apply ONLY to number input */\n        background-color: #333; /* Dark background */\n        color: #eee; /* Light text */\n        border: 1px solid #555; /* Subtle border */\n        padding: 5px 8px; /* Adjust padding as needed */\n        border-radius: 4px; /* Optional: rounded corners */\n        /* Resetting default browser appearance (optional, might remove spinners) */\n        /* -webkit-appearance: none; \n           -moz-appearance: textfield; */\n    }\n\n    /* Style focus state */\n    .form-control input[type=\"number\"]:focus { /* Apply focus ONLY to number input */\n        outline: none;\n        border-color: #777;\n        box-shadow: 0 0 3px rgba(150, 150, 150, 0.5);\n    }\n</style>",
      "templateCss" : "#container {\n    overflow: auto;\n}\n\n.tbDatasource-container {\n    margin: 5px;\n    padding: 8px;\n}\n\n.tbDatasource-title {\n    font-size: 1.200rem;\n    font-weight: 500;\n    padding-bottom: 10px;\n}\n\n.tbDatasource-table {\n    width: 100%;\n    box-shadow: 0 0 10px #ccc;\n    border-collapse: collapse;\n    white-space: nowrap;\n    font-size: 1.000rem;\n    color: #757575;\n}\n\n.tbDatasource-table td {\n    position: relative;\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n    padding: 0px 18px;\n    box-sizing: border-box;\n}",
      "controllerScript" : "'esversion: 8';\n\nfunction addSchedule() {\n    self.ctx.$scope.schedules.push({\n        startTime: '00:00',\n        endTime: '00:00',\n        setpoint: 23,\n        daysWeek: {\n            mon: false,\n            tue: false,\n            wed: false,\n            thu: false,\n            fri: false,\n            sat: false,\n            sun: false,\n        },\n        holiday: false,\n        errors: {}\n    });\n}\n\n// Helper function to convert HH:MM time to minutes since midnight\nfunction timeToMinutes(time) {\n    if (!/^[0-2][0-9]:[0-5][0-9]$/.test(time)) {\n        return NaN; // Invalid format\n    }\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n}\n\n// Validation function for a single schedule entry\nfunction validateScheduleEntry(schedule) {\n    schedule.errors = {}; // Reset errors\n\n    const startMinutes = timeToMinutes(schedule.startTime);\n    const endMinutes = timeToMinutes(schedule.endTime);\n\n    if (isNaN(startMinutes)) {\n        schedule.errors.startTime = 'Formato inválido (HH:MM).';\n    }\n    if (isNaN(endMinutes)) {\n        schedule.errors.endTime = 'Formato inválido (HH:MM).';\n    }\n\n    if (!isNaN(startMinutes) && !isNaN(endMinutes) && startMinutes >= endMinutes) {\n        schedule.errors.endTime = 'Hora final deve ser após a hora inicial.';\n    }\n\n    const daysSelected = Object.values(schedule.daysWeek).some(day => day === true);\n    if (!daysSelected && !schedule.holiday) {\n        schedule.errors.daysWeek = 'Selecione pelo menos um dia ou feriado.';\n    }\n\n    const setpoint = schedule.setpoint;\n    if (setpoint === null || setpoint === undefined || setpoint === '') {\n        schedule.errors.setpoint = 'Setpoint é obrigatório.';\n    } else {\n        const setpointNum = Number(setpoint);\n        if (!Number.isInteger(setpointNum)) {\n            schedule.errors.setpoint = 'Deve ser um número inteiro.';\n        } else if (setpointNum < 16 || setpointNum > 26) {\n            schedule.errors.setpoint = 'Deve estar entre 16 e 26.';\n        }\n    }\n\n    return Object.keys(schedule.errors).length === 0;\n}\n\n// Validation function for overlaps\nfunction validateOverlaps(schedules) {\n    let hasOverlapError = false;\n    const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];\n\n    for (let i = 0; i < schedules.length; i++) {\n        const scheduleA = schedules[i];\n        // Clear previous overlap errors for schedule A if not already set by other validation\n        if (scheduleA.errors && !scheduleA.errors.overlap) {\n             delete scheduleA.errors.overlap;\n        }\n\n        const startA = timeToMinutes(scheduleA.startTime);\n        const endA = timeToMinutes(scheduleA.endTime);\n\n        if (isNaN(startA) || isNaN(endA)) continue; // Skip if times are invalid\n\n        for (let j = i + 1; j < schedules.length; j++) {\n            const scheduleB = schedules[j];\n            // Clear previous overlap errors for schedule B if not already set by other validation\n            if (scheduleB.errors && !scheduleB.errors.overlap) {\n                 delete scheduleB.errors.overlap;\n            }\n\n            const startB = timeToMinutes(scheduleB.startTime);\n            const endB = timeToMinutes(scheduleB.endTime);\n\n            if (isNaN(startB) || isNaN(endB)) continue; // Skip if times are invalid\n\n            // Check for overlap on common active days\n            const commonDays = days.some(day => scheduleA.daysWeek[day] && scheduleB.daysWeek[day]);\n            const holidayOverlap = scheduleA.holiday && scheduleB.holiday;\n\n            if (commonDays || holidayOverlap) {\n                // Check for time interval overlap\n                if (startA < endB && endA > startB) {\n                    scheduleA.errors.overlap = 'Conflito com outro horário.';\n                    scheduleB.errors.overlap = 'Conflito com outro horário.';\n                    hasOverlapError = true;\n                }\n            }\n        }\n    }\n    return !hasOverlapError;\n}\n\n// Main validation function\nfunction validateSchedules(schedules) {\n    let allEntriesValid = true;\n    schedules.forEach(schedule => {\n        if (!validateScheduleEntry(schedule)) {\n            allEntriesValid = false;\n        }\n    });\n\n    // Only check overlaps if individual entries are potentially valid regarding time\n    let overlapsValid = true;\n    if (allEntriesValid) { // Optimization: Can skip overlap check if basic format/logic is wrong\n       overlapsValid = validateOverlaps(schedules);\n    } else {\n        // If entry validation failed, ensure any previous overlap errors are cleared\n        // unless the overlap check actually ran and set them.\n        validateOverlaps(schedules); // Run to clear/set overlap flags appropriately even if entries fail\n    }\n\n\n    return allEntriesValid && overlapsValid;\n}\n\nasync function sendRPC(centralId, payload) {\n    const $http = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\n\n    // Use the pre-constructed payload directly\n    const response = await $http.post(`https://${centralId}.y.myio.com.br/api/setpoint_schedules`, payload).toPromise();\n\n    console.log('Resposta RPC:', response);\n    return response;\n}\n\nasync function submit() {\n    // --- Pre-checks ---\n    if (self.ctx.$scope.loadError) {\n        alert('Erro de configuração: ' + self.ctx.$scope.loadError);\n        return;\n    }\n    const { fancoil, temperatureDevice, valveDevice } = self.ctx.$scope.deviceInfo;\n    if (!fancoil || !temperatureDevice || !valveDevice) {\n         alert('Erro interno: Informações do dispositivo ausentes. Verifique os aliases.');\n         console.error('Submit failed: Missing device info in scope', self.ctx.$scope.deviceInfo);\n         return;\n    }\n\n    // --- Validate Schedules ---\n    if (!validateSchedules(self.ctx.$scope.schedules)) {\n        console.log('Validation failed:', self.ctx.$scope.schedules);\n        alert('Existem erros nos agendamentos. Por favor, corrija-os.');\n        self.ctx.detectChanges();\n        return;\n    }\n    self.ctx.$scope.schedules.forEach(schedule => schedule.errors = {}); // Clear errors on success\n\n    // --- Prepare Data ---    \n    const { centralId } = self.ctx.settings;\n    const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n    const schedulesPayload = self.ctx.$scope.schedules.map(s => {\n        const { errors, ...rest } = s;\n        return rest; // Payload without errors\n    });\n\n    self.ctx.$scope.loading = true;\n    self.ctx.detectChanges();\n\n    try {\n        // --- Save Attributes to all 3 devices ---\n        const devicesToUpdate = [fancoil, temperatureDevice, valveDevice];\n        const attributesToSave = [{ key: 'schedules', value: schedulesPayload }];\n\n        for (const device of devicesToUpdate) {\n            const deviceEntityId = { id: device.id, entityType: device.entityType };\n            console.log(`Saving attributes to ${device.name} (${device.id})`);\n            await attributeService\n                .saveEntityAttributes(deviceEntityId, 'SERVER_SCOPE', attributesToSave)\n                .toPromise();\n        }\n\n        // --- Prepare and Send Consolidated RPC ---      \n        const rpcPayload = {\n            method: 'set_setpoints',\n            // 'device' field might not be needed by the API anymore if all info is in params,\n            // but keeping it as temperatureDevice for potential compatibility.\n            // Adjust or remove if the API doesn't expect it.\n            device: temperatureDevice.name, \n            params: {\n                schedules: schedulesPayload,\n                fancoilDevice: { name: fancoil.name, id: fancoil.id },\n                temperatureDevice: { name: temperatureDevice.name, id: temperatureDevice.id },\n                valveDevice: { name: valveDevice.name, id: valveDevice.id }\n            }\n        };\n\n        console.log('Enviando RPC consolidado com payload:', rpcPayload);\n        await sendRPC(centralId, rpcPayload);\n\n        alert('Agendamentos salvos com sucesso para os dispositivos configurados.');\n\n    } catch (e) {\n        console.error('Erro ao salvar agendamentos ou enviar RPC:', e);\n        alert('Erro ao salvar agendamentos. Por favor, tente novamente.');\n    } finally {\n        self.ctx.$scope.loading = false;\n        self.ctx.detectChanges();\n    }\n}\n\nasync function loadSchedules() {\n    self.ctx.$scope.loading = true; // Set loading true at the start\n    try {\n        const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n        const tempDevice = self.ctx.$scope.deviceInfo.temperatureDevice;\n\n        // Ensure temperatureDevice was found in onInit\n        if (!tempDevice) {\n            console.error('TemperatureDevice not identified. Cannot load schedules.');\n            self.ctx.$scope.loadError = \"Dispositivo de temperatura não encontrado (alias 'temperatureDevice').\";\n            self.ctx.$scope.schedules = []; // Ensure schedules is empty\n            return; // Exit early\n        }\n\n        const deviceEntityId = { id: tempDevice.id, entityType: tempDevice.entityType };\n\n        console.log('Loading schedules from:', tempDevice.name);\n        const attributes = await attributeService.getEntityAttributes(deviceEntityId, 'SERVER_SCOPE', ['schedules']).toPromise();\n        const schedulesAttr = attributes.find(attr => attr.key === 'schedules');\n\n        if (schedulesAttr && schedulesAttr.value && Array.isArray(schedulesAttr.value)) {\n            self.ctx.$scope.schedules = schedulesAttr.value.map(s => ({\n                ...s,\n                setpoint: s.setpoint !== undefined ? s.setpoint : 23,\n                errors: s.errors || {}\n            }));\n            console.log('Agendamentos carregados:', self.ctx.$scope.schedules);\n        } else {\n            console.log('Nenhum agendamento salvo encontrado no dispositivo de temperatura.');\n            self.ctx.$scope.schedules = []; // Initialize if none found\n        }\n    } catch (e) {\n        console.error('Erro ao carregar agendamentos:', e);\n        self.ctx.$scope.loadError = \"Erro ao carregar agendamentos.\";\n        self.ctx.$scope.schedules = []; // Ensure schedules is empty on error\n    } finally {\n         self.ctx.$scope.loading = false; // Set loading false at the end\n         self.ctx.detectChanges();\n    }\n}\n\nfunction remove(schedule) {\n    const index = self.ctx.$scope.schedules.indexOf(schedule);\n    if (index > -1) { // Check if found\n        self.ctx.$scope.schedules.splice(index, 1);\n        // Re-validate after removing an item as overlaps might change\n        validateSchedules(self.ctx.$scope.schedules);\n        self.ctx.detectChanges();\n    }\n}\n\nself.onInit = async function() {\n    self.ctx.$scope.loading = true;\n    self.ctx.$scope.loadError = null; // Initialize load error message\n    self.ctx.$scope.deviceInfo = { // Store device details here\n        fancoil: null,\n        temperatureDevice: null,\n        valveDevice: null\n    };\n\n    // --- Identify Devices by Alias ---\n    const requiredAliases = ['fancoil', 'temperatureDevice', 'valveDevice'];\n    let foundAliases = new Set();\n\n    if (self.ctx.data && self.ctx.data.length > 0) {\n        self.ctx.data.forEach(datasource => {\n            // console.log('datasource:', datasource); // Keep this log for debugging if needed\n            // --- MODIFIED: Use dataKey.label instead of datasource.alias ---\n            const alias = datasource.dataKey ? datasource.dataKey.label : null;\n            // --------------------------------------------------------------\n            if (alias && requiredAliases.includes(alias)) {\n                 if (self.ctx.$scope.deviceInfo[alias]) {\n                     console.warn(`Duplicate alias (dataKey label) found: ${alias}. Using the first one encountered.`);\n                 } else {\n                     self.ctx.$scope.deviceInfo[alias] = {\n                         name: datasource.datasource.entityName,\n                         id: datasource.datasource.entityId,\n                         entityType: datasource.datasource.entityType\n                     };\n                     foundAliases.add(alias);\n                     console.log(`Identified ${alias}:`, self.ctx.$scope.deviceInfo[alias].name);\n                 }\n            }\n        });\n    }\n\n    // --- Check if all required devices were found ---\n    if (foundAliases.size !== requiredAliases.length) {\n         const missingAliases = requiredAliases.filter(a => !foundAliases.has(a));\n         console.error('Missing required device aliases:', missingAliases);\n         self.ctx.$scope.loadError = `Erro: Falta(m) alias(es) de dispositivo(s) obrigatório(s): ${missingAliases.join(', ')}.`;\n         self.ctx.$scope.loading = false;\n         self.ctx.detectChanges();\n         return; // Stop initialization\n    }\n\n    // --- Setup Scope Functions ---\n    self.ctx.$scope.addSchedule = addSchedule;\n    self.ctx.$scope.submit = submit; // submit will be modified next\n    self.ctx.$scope.remove = remove;\n\n    self.ctx.$scope.schedules = [];\n\n    // --- Load Schedules (now uses identified temperatureDevice) ---\n    await loadSchedules(); // loadSchedules now sets loading to false and detects changes\n\n    // self.ctx.$scope.loading = false; // Moved inside loadSchedules finally block\n    // self.ctx.detectChanges(); // Moved inside loadSchedules finally block\n}\n\nself.onDataUpdated = function() {}\n\nself.onDestroy = function() {}\n",
      "settingsSchema" : "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"centralId\": {\r\n                \"type\": \"string\",\r\n                \"title\": \"Id da Central\"\r\n            }\r\n        },\r\n        \"required\": [\"centralId\"]\r\n    },\r\n    \"form\": [\r\n        \"centralId\"\r\n    ]\r\n}",
      "dataKeySettingsSchema" : "{}\n",
      "dataKeySettingsDirective" : "tb-value-card-widget-settings",
      "hasBasicMode" : true,
      "defaultConfig" : "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Agendamento_simples_Temp\",\"decimals\":null}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "4607a9e0-4546-11f0-bdaa-1bbe0793dcff"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}