{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "configura_o_presen_a",
    "name" : "Configuração Presença",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "latest",
      "sizeX" : 7.5,
      "sizeY" : 12,
      "resources" : [ ],
      "templateHtml" : "<div class=\"presence-sensor-container\">\n    <div class=\"sensor-header\">\n        <h2 class=\"sensor-title\">Sensor de Presença {{entityName}}</h2>\n    </div>\n\n    <div class=\"presence-form\">\n        <!-- Presence Detection Configuration -->\n        <div class=\"form-section\">\n            <label class=\"form-label\">Se Tiver Presença Por</label>\n            <div class=\"time-input-group\" *ngIf=\"formData\">\n                <input type=\"number\" \n                       class=\"time-input\" \n                       [(ngModel)]=\"formData.presenceTime\"\n                       min=\"1\"\n                       placeholder=\"0\">\n                <select class=\"time-unit-select\" [(ngModel)]=\"formData.presenceTimeUnit\">\n                    <option value=\"seconds\">Segundos</option>\n                    <option value=\"minutes\">Minutos</option>\n                    <option value=\"hours\">Horas</option>\n                </select>\n            </div>\n        </div>\n\n        <!-- Command Selection -->\n        <div class=\"form-section\" *ngIf=\"formData\">\n            <label class=\"form-label\">Comando</label>\n            <select class=\"command-select\" [(ngModel)]=\"formData.selectedCommand\">\n                <option [ngValue]=\"null\">Selecione um comando</option>\n                <option *ngFor=\"let command of commands\" [ngValue]=\"command\">\n                    {{command.name}}\n                </option>\n            </select>\n        </div>\n\n        <!-- Repeat Command Configuration -->\n        <div class=\"form-section\" *ngIf=\"formData\">\n            <div class=\"checkbox-group\">\n                <label class=\"checkbox-label\">\n                    <input type=\"checkbox\" \n                           class=\"repeat-checkbox\"\n                           [(ngModel)]=\"formData.repeatCommand\"\n                           (change)=\"onRepeatToggle()\">\n                    <span class=\"checkbox-text\">Repetir Comando a cada</span>\n                </label>\n            </div>\n            \n            <div class=\"time-input-group\" \n                 [class.disabled]=\"!formData.repeatCommand\"\n                 *ngIf=\"formData.repeatCommand\">\n                <input type=\"number\" \n                       class=\"time-input\" \n                       [(ngModel)]=\"formData.repeatTime\"\n                       min=\"1\"\n                       placeholder=\"0\"\n                       [disabled]=\"!formData.repeatCommand\">\n                <select class=\"time-unit-select\" \n                        [(ngModel)]=\"formData.repeatTimeUnit\"\n                        [disabled]=\"!formData.repeatCommand\">\n                    <option value=\"seconds\">Segundos</option>\n                    <option value=\"minutes\">Minutos</option>\n                    <option value=\"hours\">Horas</option>\n                </select>\n            </div>\n        </div>\n\n        <!-- Action Buttons -->\n        <div class=\"form-actions\" *ngIf=\"formData\">\n            <button type=\"button\" \n                    class=\"save-button\" \n                    [disabled]=\"!isFormValid() || loading\"\n                    (click)=\"saveConfiguration()\">\n                <span *ngIf=\"!loading\">Salvar</span>\n                <span *ngIf=\"loading\" class=\"loading-text\">Salvando...</span>\n            </button>\n        </div>\n    </div>\n\n    <!-- Loading Animation -->\n    <div *ngIf=\"loading\" class=\"loading-overlay\">\n        <div class=\"spinner\"></div>\n    </div>\n\n    <!-- Success Message -->\n    <div *ngIf=\"showSuccess\" class=\"success-message\">\n        <div class=\"success-icon\">✓</div>\n        <span>Configuração salva com sucesso!</span>\n    </div>\n\n    <!-- Error Message -->\n    <div *ngIf=\"showError\" class=\"error-message\">\n        <div class=\"error-icon\">✗</div>\n        <span>Erro ao salvar configuração!</span>\n    </div>\n</div> ",
      "templateCss" : "/* Main Container */\n.presence-sensor-container {\n    width: 100%;\n    max-width: 600px;\n    margin: 0 auto;\n    padding: 20px;\n    background-color: #191B1F;\n    border-radius: 12px;\n    color: white;\n    font-family: 'Roboto', Arial, sans-serif;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n/* Header */\n.sensor-header {\n    text-align: center;\n    margin-bottom: 30px;\n}\n\n.sensor-title {\n    font-size: 24px;\n    font-weight: 600;\n    margin: 0;\n    color: #FFFFFF;\n    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n/* Form Styling */\n.presence-form {\n    display: flex;\n    flex-direction: column;\n    gap: 25px;\n}\n\n.form-section {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n}\n\n.form-label {\n    font-size: 16px;\n    font-weight: 500;\n    color: #E0E0E0;\n    margin-bottom: 8px;\n}\n\n/* Time Input Group */\n.time-input-group {\n    display: flex;\n    gap: 12px;\n    align-items: center;\n}\n\n.time-input {\n    flex: 1;\n    max-width: 120px;\n    padding: 12px 16px;\n    border: 2px solid #333;\n    border-radius: 8px;\n    background-color: #2C2F33;\n    color: white;\n    font-size: 16px;\n    transition: all 0.3s ease;\n}\n\n.time-input:focus {\n    outline: none;\n    border-color: #0094FF;\n    box-shadow: 0 0 0 3px rgba(0, 148, 255, 0.1);\n}\n\n.time-unit-select {\n    flex: 2;\n    min-width: 140px;\n    padding: 12px 16px;\n    border: 2px solid #333;\n    border-radius: 8px;\n    background-color: #2C2F33;\n    color: white;\n    font-size: 16px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.time-unit-select:focus {\n    outline: none;\n    border-color: #0094FF;\n    box-shadow: 0 0 0 3px rgba(0, 148, 255, 0.1);\n}\n\n.time-unit-select option {\n    background-color: #2C2F33;\n    color: white;\n    padding: 8px;\n}\n\n/* Command Selection */\n.command-select {\n    width: 100%;\n    padding: 12px 16px;\n    border: 2px solid #333;\n    border-radius: 8px;\n    background-color: #2C2F33;\n    color: white;\n    font-size: 16px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.command-select:focus {\n    outline: none;\n    border-color: #0094FF;\n    box-shadow: 0 0 0 3px rgba(0, 148, 255, 0.1);\n}\n\n.command-select option {\n    background-color: #2C2F33;\n    color: white;\n    padding: 8px;\n}\n\n/* Checkbox Styling */\n.checkbox-group {\n    margin-bottom: 12px;\n}\n\n.checkbox-label {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    cursor: pointer;\n    font-size: 16px;\n    font-weight: 500;\n}\n\n.repeat-checkbox {\n    width: 20px;\n    height: 20px;\n    accent-color: #0094FF;\n    cursor: pointer;\n}\n\n.checkbox-text {\n    color: #E0E0E0;\n    user-select: none;\n}\n\n/* Disabled State */\n.time-input-group.disabled {\n    opacity: 0.5;\n    pointer-events: none;\n}\n\n.time-input:disabled,\n.time-unit-select:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n    background-color: #1A1D21;\n}\n\n/* Action Buttons */\n.form-actions {\n    display: flex;\n    justify-content: center;\n    margin-top: 30px;\n}\n\n.save-button {\n    padding: 14px 32px;\n    background: linear-gradient(135deg, #0094FF 0%, #0066CC 100%);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    font-size: 16px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 15px rgba(0, 148, 255, 0.3);\n    min-width: 120px;\n}\n\n.save-button:hover:not(:disabled) {\n    background: linear-gradient(135deg, #0066CC 0%, #004499 100%);\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(0, 148, 255, 0.4);\n}\n\n.save-button:disabled {\n    background: #333;\n    cursor: not-allowed;\n    transform: none;\n    box-shadow: none;\n    opacity: 0.6;\n}\n\n.loading-text {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n/* Loading Animation */\n.loading-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(25, 27, 31, 0.8);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 12px;\n}\n\n.spinner {\n    width: 40px;\n    height: 40px;\n    border: 4px solid #333;\n    border-top: 4px solid #0094FF;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Success Message */\n.success-message {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: linear-gradient(135deg, #4CAF50 0%, #45A049 100%);\n    color: white;\n    padding: 16px 24px;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);\n    animation: slideInRight 0.3s ease-out;\n    z-index: 1000;\n}\n\n.success-icon {\n    font-size: 20px;\n    font-weight: bold;\n}\n\n/* Error Message */\n.error-message {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);\n    color: white;\n    padding: 16px 24px;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);\n    animation: slideInRight 0.3s ease-out;\n    z-index: 1000;\n}\n\n.error-icon {\n    font-size: 20px;\n    font-weight: bold;\n}\n\n@keyframes slideInRight {\n    from {\n        transform: translateX(100%);\n        opacity: 0;\n    }\n    to {\n        transform: translateX(0);\n        opacity: 1;\n    }\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .presence-sensor-container {\n        padding: 16px;\n        margin: 10px;\n    }\n    \n    .sensor-title {\n        font-size: 20px;\n    }\n    \n    .time-input-group {\n        flex-direction: column;\n        gap: 8px;\n    }\n    \n    .time-input,\n    .time-unit-select {\n        max-width: none;\n        min-width: auto;\n        width: 100%;\n    }\n    \n    .success-message,\n    .error-message {\n        position: fixed;\n        top: 10px;\n        left: 10px;\n        right: 10px;\n        margin: 0;\n    }\n}\n\n/* Focus and Interaction States */\ninput[type=\"number\"]::-webkit-outer-spin-button,\ninput[type=\"number\"]::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n}\n\ninput[type=\"number\"] {\n    -moz-appearance: textfield;\n}\n\n/* Smooth transitions for all interactive elements */\n* {\n    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, transform 0.3s ease;\n} ",
      "controllerScript" : "'esversion: 8'\n// async function getAlarms() {}\n\n// ----- CONSTANTS -----\n// Remove ALARM_TYPES as we only have one type now.\n\n// ----- INTERNAL STATE UPDATE FUNCTIONS -----\nfunction _updateSaveButtonState() {\n    const $scope = self.ctx.$scope;\n    if (!$scope) return; // Safety check\n\n    let isDisabled = false;\n    if ($scope.loading) {\n        isDisabled = true;\n    } else if (!$scope.demandRules || $scope.demandRules.length === 0) { // Should always have one rule\n        isDisabled = true;\n    } else if (!$scope.demandRules[0] || !$scope.demandRules[0].ruleFormGroup || !$scope.demandRules[0].ruleFormGroup.valid) {\n        isDisabled = true;\n    }\n    $scope.saveButtonDisabled = isDisabled;\n    // console.log('Save button disabled state updated:', $scope.saveButtonDisabled);\n}\n\n// ----- DEMAND RULE MANAGEMENT FUNCTIONS -----\nfunction initializeDemandRule(rule = {}) {\n    const $scope = self.ctx.$scope;\n    \n    // Custom validator for power range\n    const powerRangeValidator = (formGroup) => {\n        const minPower = formGroup.get('minPower').value;\n        const maxPower = formGroup.get('maxPower').value;\n        \n        if (minPower !== null && maxPower !== null && minPower > maxPower) {\n            return { powerRange: true };\n        }\n        return null;\n    };\n\n    // Custom validator for control devices (ensure at least one selected)\n    const controlDevicesRequiredValidator = (control) => {\n        if (!control.value || control.value.length === 0) {\n            return { required: true };\n        }\n        return null;\n    };\n    \n    // Initialize form group with demand control fields\n    const ruleFormGroup = $scope.fb.group({\n        'minPower': [null, [ $scope.validators.required, $scope.validators.min(0) ]],\n        'maxPower': [null, [ $scope.validators.required, $scope.validators.min(0) ]],\n        'controlDevices': [[], [ controlDevicesRequiredValidator ]]\n    }, { validators: powerRangeValidator });\n\n    // Subscribe to value changes to update save button state\n    ruleFormGroup.valueChanges.subscribe(() => {\n        _updateSaveButtonState();\n    });\n     ruleFormGroup.statusChanges.subscribe(() => { \n        _updateSaveButtonState();\n    });\n\n    // Initialize patch values - Convert Watts to kW for display\n    const patchValues = {\n        minPower: rule.minPower !== null && rule.minPower !== undefined ? rule.minPower / 1000 : null,\n        maxPower: rule.maxPower !== null && rule.maxPower !== undefined ? rule.maxPower / 1000 : null,\n        controlDevices: []\n    };\n\n    if (rule.controlDevices && Array.isArray(rule.controlDevices)) {\n        patchValues.controlDevices = rule.controlDevices.map(device => ({\n            id: device.id ? (typeof device.id === 'object' ? device.id.id : device.id) : null,\n            name: device.name || device.label || 'Unknown device'\n        })).filter(d => d.id);\n    }\n\n    ruleFormGroup.patchValue(patchValues);\n    ruleFormGroup.updateValueAndValidity();\n\n    const _rule = {\n        minPower: patchValues.minPower,\n        maxPower: patchValues.maxPower,\n        controlDevices: patchValues.controlDevices,\n        ruleFormGroup\n    };\n    \n    self.ctx.$scope.demandRules = [_rule]; // Always a single rule\n    _updateSaveButtonState(); \n    self.ctx.detectChanges();\n}\n\n// ----- API Functions -----\nasync function sendRPC(centralId, body) {\n    const $http = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'),);\n    const response = await $http.post(`https://${centralId}.y.myio.com.br/api/rpc`, body).toPromise();\n    \n    //console.log(response);\n    \n    return response;\n}\n\nasync function submit() {\n    self.ctx.$scope.submitted = true;\n    _updateSaveButtonState(); \n\n    if (self.ctx.$scope.saveButtonDisabled) { \n        alert('Por favor, corrija os erros no formulário antes de salvar.');\n        return;\n    }\n\n    const { centralId, customerId } = self.ctx.settings;\n    const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n\n    const singleRuleFormValues = self.ctx.$scope.demandRules[0].ruleFormGroup.value;\n\n    let controlDevicesToSave = [];\n    if (singleRuleFormValues.controlDevices && Array.isArray(singleRuleFormValues.controlDevices)) {\n        controlDevicesToSave = singleRuleFormValues.controlDevices.map(device => ({\n            id: device.id ? (typeof device.id === 'object' ? device.id.id : device.id) : null,\n            name: device.name || device.label || 'Unknown device'\n        })).filter(d => d.id);\n    }\n    \n    // Convert kW to Watts for storage\n    const minPowerWatts = singleRuleFormValues.minPower * 1000;\n    const maxPowerWatts = singleRuleFormValues.maxPower * 1000;\n    \n    const attributes = [\n        { key: 'minPower', value: minPowerWatts },\n        { key: 'maxPower', value: maxPowerWatts },\n        { key: 'controlDevices', value: controlDevicesToSave }\n    ];\n\n    // Data for RPC - send in kW (original form values)\n    const rpcParams = {\n        minPower: singleRuleFormValues.minPower,\n        maxPower: singleRuleFormValues.maxPower,\n        controlDevices: controlDevicesToSave\n    };\n\n    const entityName = self.ctx.defaultSubscription\n        .data[0].datasource.entityName;\n    const entityId = {\n        id: self.ctx.defaultSubscription.data[0]\n            .datasource.entityId,\n        entityType: self.ctx.defaultSubscription.data[0].datasource.entityType || 'DEVICE',\n    };\n\n    console.log('Entity id: ', entityId);\n    console.log('Saving attributes (in Watts): ', attributes);\n    console.log('RPC params (in kW): ', rpcParams);\n\n    try {\n        await sendRPC(centralId, {\n            device: entityName,\n            method: 'updateDemand',\n            params: rpcParams, // Send data as a single object for RPC\n        });\n\n        await attributeService\n             .saveEntityAttributes(entityId, 'SHARED_SCOPE',\n                 attributes) // Save attributes individually\n             .toPromise();\n             \n        alert('Salvo com sucesso.');\n\n    } catch (e) {\n        console.log('E:', e);\n        alert('Erro ao salvar ou dispositivo inativo.');\n    }\n}\n\n// ----- Lifecycle Hooks -----\nself.onInit = async function() {\n    self.ctx.$scope.loading = true; \n    self.ctx.$scope.saveButtonDisabled = true;\n    console.log('v1.1 - Single Demand Control Widget Init');\n\n    if (!self.ctx.$scope.fb) {\n        console.error('FormBuilder (fb) is not available on the scope.');\n        self.ctx.$scope.loading = false;\n        _updateSaveButtonState();\n        self.ctx.detectChanges(); \n        return;\n    }\n\n    self.ctx.$scope.onDeviceSearchInputChange = onDeviceSearchInputChange;\n    self.ctx.$scope.displayDeviceFn = displayDeviceFn;\n    self.ctx.$scope.submit = submit;\n    self.ctx.$scope.compareDeviceObjects = compareDeviceObjects;\n    self.ctx.$scope.initializeDemandRule = initializeDemandRule; // Expose for potential re-initialization if needed\n\n    self.ctx.$scope.demandRules = []; // Will contain a single rule object\n    self.ctx.$scope.filteredDevices = [];\n    self.ctx.$scope.deviceSearchText = '';\n    \n    try {\n        const entityDatasource = self.ctx.defaultSubscription.data[0].datasource;\n        self.ctx.$scope.entityName = entityDatasource.entityLabel;\n        self.ctx.$scope.entityId = entityDatasource.entityId;\n        const entityType = entityDatasource.entityType || 'DEVICE';\n\n        const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n        // Fetch individual attributes\n        const attributeKeys = ['minPower', 'maxPower', 'controlDevices'];\n        const attributesData = await attributeService.getEntityAttributes(\n            { id: self.ctx.$scope.entityId, entityType: entityType },\n            'SHARED_SCOPE',\n            attributeKeys\n        ).toPromise();\n\n        const savedRuleData = {};\n        attributesData.forEach(attr => {\n            savedRuleData[attr.key] = attr.value;\n        });\n        \n        console.log('Loaded saved attributes:', savedRuleData);\n\n        // Ensure controlDevices is an array, even if null/undefined from attributes\n        const controlDevices = Array.isArray(savedRuleData.controlDevices) ? savedRuleData.controlDevices.map(d => ({\n            id: d.id ? (typeof d.id === 'object' ? d.id.id : d.id) : null,\n            name: d.name || d.label || 'Unknown device'\n        })).filter(d => d.id) : [];\n\n        const initialRule = {\n            minPower: savedRuleData.minPower !== undefined ? savedRuleData.minPower : null,\n            maxPower: savedRuleData.maxPower !== undefined ? savedRuleData.maxPower : null,\n            controlDevices: controlDevices\n        };\n        \n        initializeDemandRule(initialRule);\n\n    } catch (error) {\n        console.error('Error during onInit (loading attributes, entity info, or processing rule):', error);\n        // Initialize with an empty rule if loading fails\n        initializeDemandRule({}); \n    } finally {\n        self.ctx.$scope.loading = false;\n        _updateSaveButtonState(); \n        self.ctx.detectChanges();     \n    }\n};\n\nself.onDataUpdated = function() {\n    _updateSaveButtonState(); // Update on any external data update\n    self.ctx.detectChanges();\n}\n\nself.onDestroy = function() {\n    // Unsubscribe from form changes if necessary, though usually handled by Angular's destruction\n    self.ctx.detectChanges();\n}\n\n// ----- Device Search Functions -----\nasync function searchDevices(searchText) {\n    try {\n        console.log(\"Searching for devices with text:\", searchText);\n        const deviceService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('deviceService'));\n        const customerId = self.ctx.settings.customerId;\n        \n        if (!customerId) {\n            console.warn(\"No customer ID available for device search, trying tenant level\");\n            // Attempt tenant level search if customerId is missing\n             const pageLink = {\n                page: 0,\n                pageSize: 50,\n                textSearch: searchText,\n                toQuery: function() {\n                    let query = `?pageSize=${this.pageSize}&page=${this.page}`;\n                    if (this.textSearch && this.textSearch.trim().length) {\n                        const textSearch = encodeURIComponent(this.textSearch.trim());\n                        query += `&textSearch=${textSearch}`;\n                    }\n                    return query;\n                }\n            };\n            try {\n                const result = await deviceService.getTenantDeviceInfos(pageLink).toPromise();\n                 if (result && result.data) {\n                    return result.data;\n                }\n            } catch (tenantError) {\n                 console.error(\"Tenant device search also failed:\", tenantError);\n                 return [];\n            }\n            return [];\n        }\n        \n        // Create a plain object that matches the expected PageLink structure\n        const pageLink = {\n            page: 0,\n            pageSize: 50,\n            textSearch: searchText,\n            toQuery: function() {\n                let query = `?pageSize=${this.pageSize}&page=${this.page}`;\n                if (this.textSearch && this.textSearch.trim().length) {\n                    const textSearch = encodeURIComponent(this.textSearch.trim());\n                    query += `&textSearch=${textSearch}`;\n                }\n                return query;\n            }\n        };\n        \n        try {\n            let result = await deviceService.getCustomerDeviceInfos(false, customerId, pageLink).toPromise();\n            \n            if (!result || !result.data || result.data.length === 0) {\n                result = await deviceService.getCustomerDeviceInfos(true, customerId, pageLink).toPromise();\n            }\n            \n            if (result && result.data) {\n                return result.data;\n            }\n            return [];\n        } catch (e) {\n            console.error(\"Error calling getCustomerDeviceInfos:\", e);\n            return [];\n        }\n    } catch (e) {\n        console.error(\"Error in device search:\", e);\n        return [];\n    }\n}\n\nfunction displayDeviceFn(device) {\n    if (!device) return '';\n    \n    if (typeof device === 'string') return device;\n    if (device.name) return device.name;\n    if (device.label) return device.label;\n    if (device.title) return device.title;\n    \n    if (device.id) {\n        if (typeof device.id === 'string') return device.id;\n        if (device.id.id) return device.id.id;\n    }\n    \n    return 'Unknown device';\n}\n\nfunction onDeviceSearchInputChange(searchText) {\n    const effectiveSearchText = searchText !== undefined ? searchText : self.ctx.$scope.deviceSearchText;\n\n    if (effectiveSearchText && effectiveSearchText.length >= 2) {\n        console.log('Device search triggered for:', effectiveSearchText);\n        // Set loading for device search if you want UI feedback\n        // self.ctx.$scope.deviceSearchLoading = true; \n        // _updateSaveButtonState(); // If device search affects save button\n        // self.ctx.detectChanges();\n\n        searchDevices(effectiveSearchText).then(devices => {\n            console.log('Found devices:', devices.length);\n            \n            const formattedDevices = devices.map(device => {\n                const deviceId = device.id ? (typeof device.id === 'object' ? device.id.id : device.id) : null;\n                const displayName = device.name || device.label || deviceId || 'Unknown device';\n                return {\n                    id: deviceId,\n                    name: displayName\n                };\n            }).filter(d => d.id);\n            \n            self.ctx.$scope.filteredDevices = formattedDevices;\n        }).catch(err => {\n            console.error(\"Error in device search:\", err);\n            self.ctx.$scope.filteredDevices = [];\n        }).finally(() => {\n            // self.ctx.$scope.deviceSearchLoading = false;\n            // _updateSaveButtonState();\n            self.ctx.detectChanges();\n        });\n    } else {\n        self.ctx.$scope.filteredDevices = [];\n        self.ctx.detectChanges();\n    }\n}\n\nfunction compareDeviceObjects(o1, o2) {\n    return o1 && o2 ? o1.id === o2.id : o1 === o2;\n}",
      "settingsSchema" : "{}",
      "dataKeySettingsSchema" : "{}\n",
      "defaultConfig" : "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Attributes card\",\"decimals\":null}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "154d8d00-3fc0-11f0-bdaa-1bbe0793dcff"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}