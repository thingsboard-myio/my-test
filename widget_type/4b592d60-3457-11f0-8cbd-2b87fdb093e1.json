{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "energy_report",
    "name" : "Energy Report",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "timeseries",
      "sizeX" : 8,
      "sizeY" : 5.5,
      "resources" : [ {
        "url" : "https://graphs.ingestion.myio-bas.com/sdk/energy-chart-sdk.umd.js"
      } ],
      "templateHtml" : "<div class=\"myio-report-widget\">\n    <div class=\"myio-report-header\">\n        <h2 class=\"myio-report-title\">{{widgetTitle}}</h2>\n        <button mat-flat-button color=\"primary\" (click)=\"exportToCSV()\" [disabled]=\"isLoading || !reportData || reportData.length === 0\">\n            <mat-icon>get_app</mat-icon> Export CSV\n        </button>\n    </div>\n\n    <div *ngIf=\"isLoading\" class=\"myio-loading-message\">\n        <mat-spinner diameter=\"30\"></mat-spinner>\n        <span>Carregando dados...</span>\n    </div>\n\n    <div *ngIf=\"!isLoading && errorMessage\" class=\"myio-error-message\">\n        {{errorMessage}}\n    </div>\n\n    <div *ngIf=\"!isLoading && !errorMessage && (!reportData || reportData.length === 0)\" class=\"myio-no-data-message\">\n        Nenhum dispositivo configurado ou nenhum dado para exibir.\n    </div>\n\n    <div *ngIf=\"!isLoading && !errorMessage && reportData && reportData.length > 0\" class=\"myio-report-table-container\">\n        <table class=\"myio-report-table\">\n            <thead>\n                <tr>\n                    <th>Nome do Dispositivo</th>\n                    <th>Consumo no Período (kWh)</th> \n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor=\"let device of reportData\">\n                    <td data-label=\"Nome do Dispositivo\">{{device.deviceName}}</td>\n                    <td data-label=\"Consumo (kWh)\">\n                        {{ device.consumptionKwh }}\n                        <!-- <span *ngIf=\"device.error\" class=\"myio-device-error\">Erro: {{device.error}}</span> -->\n                        <!-- <span *ngIf=\"!device.error && device.consumptionKwh !== null\">{{device.consumptionKwh | number:consumptionDecimals}}</span> -->\n                        <!-- <span *ngIf=\"!device.error && device.consumptionKwh === null\">N/A</span> -->\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</div> ",
      "templateCss" : ".myio-report-widget {\n    padding: 16px;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    box-sizing: border-box;\n    background-color: var(--tb-service-background, #fff);\n}\n\n.myio-report-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n}\n\n.myio-report-title {\n    margin: 0;\n    font-size: 1.25rem;\n    font-weight: 500;\n    color: var(--tb-text-color, #333);\n}\n\n.myio-report-header button {\n    font-size: 0.875rem;\n}\n\n.myio-report-header button mat-icon {\n    margin-right: 6px;\n}\n\n.myio-loading-message,\n.myio-error-message,\n.myio-no-data-message {\n    display: flex;\n    flex-direction: column; /* Stack spinner and text */\n    align-items: center;\n    justify-content: center;\n    text-align: center;\n    padding: 20px;\n    color: var(--tb-text-color-secondary, #757575);\n    flex-grow: 1; /* Take remaining space if table not shown */\n}\n\n.myio-loading-message mat-spinner {\n    margin-bottom: 10px;\n}\n\n.myio-error-message {\n    color: var(--tb-danger-500, #D32F2F);\n    white-space: normal; /* Allow error messages to wrap */\n}\n\n.myio-report-table-container {\n    flex-grow: 1;\n    overflow-y: auto; /* Allow table to scroll if content overflows */\n    border: 1px solid var(--tb-border-color, rgba(0,0,0,0.12));\n    border-radius: var(--tb-border-radius, 4px);\n}\n\n.myio-report-table {\n    width: 100%;\n    border-collapse: collapse;\n}\n\n.myio-report-table th,\n.myio-report-table td {\n    padding: 10px 12px;\n    text-align: left;\n    border-bottom: 1px solid var(--tb-border-color, rgba(0,0,0,0.12));\n}\n\n.myio-report-table th {\n    font-weight: 500;\n    background-color: var(--tb-background, #f5f5f5); /* Subtle header background */\n    color: var(--tb-text-color, #333);\n    position: sticky; /* Make header sticky */\n    top: 0;\n    z-index: 1;\n}\n\n.myio-report-table tbody tr:nth-child(even) {\n    background-color: var(--tb-hover-background, #fafafa); /* Zebra striping */\n}\n\n.myio-report-table tbody tr:hover {\n    background-color: var(--tb-highlight-color-hover, #f0f0f0);\n}\n\n.myio-device-error {\n    color: var(--tb-danger-500, #D32F2F);\n    font-style: italic;\n    font-size: 0.9em;\n}\n\n/* Responsive adjustments for smaller screens if needed in the future */\n/* @media (max-width: 600px) { ... } */ ",
      "controllerScript" : "self.onInit = async function() {\n    // Scope Initialization\n    self.ctx.$scope.widgetTitle = self.ctx.settings.widgetTitle || \"Energy Consumption Report\";\n    self.ctx.$scope.apiBaseUrl = self.ctx.settings.apiBaseUrl || 'https://ingestion.myio-bas.com'; // Default, should be in settings\n    self.ctx.$scope.consumptionDecimals = self.ctx.settings.consumptionDecimals !== undefined ? self.ctx.settings.consumptionDecimals : 2;\n    self.ctx.$scope.exportFileName = self.ctx.settings.exportFileName || 'energy_consumption_report.csv';\n\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null;\n    self.ctx.$scope.reportData = []; // Array of { entityId, deviceName, centralId, slaveId, consumptionKwh, error }\n\n    // Internal state\n    let resolveInitializationPromise;\n    self.initializationPromise = new Promise(resolve => {\n        resolveInitializationPromise = resolve;\n    });\n\n    self.ctx.$scope.exportToCSV = function() {\n        if (!self.ctx.$scope.reportData || self.ctx.$scope.reportData.length === 0) {\n            return;\n        }\n\n        const decimals = self.ctx.$scope.consumptionDecimals;\n        let csvContent = \"Device Name,Consumption in the period (kWh)\\n\"; // Header\n\n        self.ctx.$scope.reportData.forEach(device => {\n            const deviceName = device.deviceName.replace(/\"/g, '\"\"'); // Escape double quotes\n            let consumptionValue = 'N/A';\n            if (device.error) {\n                consumptionValue = `Error: ${device.error.replace(/\"/g, '\"\"')}`;\n            } else if (device.consumptionKwh !== null) {\n                consumptionValue = device.consumptionKwh.toFixed(decimals);\n            }\n            csvContent += `\"${deviceName}\",\"${consumptionValue}\"\\n`;\n        });\n\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement(\"a\");\n        if (link.download !== undefined) { // feature detection\n            const url = URL.createObjectURL(blob);\n            link.setAttribute(\"href\", url);\n            link.setAttribute(\"download\", self.ctx.$scope.exportFileName);\n            link.style.visibility = 'hidden';\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n        } else {\n            // Fallback for older browsers or environments where download attribute is not supported\n            alert(\"CSV export via direct download is not supported in your browser. Please try a modern browser.\");\n            // Or, potentially, display the CSV content in a modal for copy-pasting.\n        }\n    }; \n\n    try {\n        const attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\n        const datasources = self.ctx.defaultSubscription.datasources;\n\n        if (!datasources || datasources.length === 0) {\n            self.ctx.$scope.errorMessage = \"Nenhum dispositivo configurado. Adicione dispositivos à fonte de dados do widget.\";\n            self.ctx.$scope.isLoading = false;\n            resolveInitializationPromise();\n            self.ctx.detectChanges();\n            return;\n        }\n\n        const attributeFetchPromises = datasources.map(async (ds) => {\n            const entityLabel = ds.entityName || ds.label || `Dispositivo (ID: ${ds.entityId.substring(0,5)})`;\n            let deviceReportEntry = {\n                entityId: ds.entityId,\n                entityAliasId: ds.entityAliasId,\n                deviceName: entityLabel,\n                centralId: null,\n                slaveId: null,\n                consumptionKwh: null,\n                error: null\n            };\n\n            try {\n                if (!ds.entityId || !ds.entityType) {\n                    throw new Error(\"Contexto do dispositivo (entityId/entityType) ausente na fonte de dados.\");\n                }\n                const deviceAttributes = await attributeService.getEntityAttributes(\n                    { id: ds.entityId, entityType: ds.entityType },\n                    'SERVER_SCOPE',\n                    ['centralId', 'slaveId']\n                ).toPromise();\n\n                const centralIdAttr = deviceAttributes.find(attr => attr.key === 'centralId');\n                const slaveIdAttr = deviceAttributes.find(attr => attr.key === 'slaveId');\n\n                const centralIdValue = centralIdAttr ? centralIdAttr.value : null;\n                const slaveIdRawValue = slaveIdAttr ? slaveIdAttr.value : null;\n                const slaveIdValue = typeof slaveIdRawValue === 'string' ? parseInt(slaveIdRawValue, 10) : slaveIdRawValue;\n\n                if (!centralIdValue || slaveIdValue === null || typeof slaveIdValue !== 'number' || isNaN(slaveIdValue)) {\n                    throw new Error(\"Atributos centralId/slaveId ausentes ou inválidos.\");\n                }\n                deviceReportEntry.centralId = centralIdValue;\n                deviceReportEntry.slaveId = slaveIdValue;\n            } catch (attrError) {\n                console.error(`Erro ao buscar atributos para ${entityLabel} (ID: ${ds.entityId}):`, attrError);\n                deviceReportEntry.error = attrError.message || \"Falha ao buscar atributos.\";\n            }\n            return deviceReportEntry;\n        });\n\n        self.ctx.$scope.reportData = await Promise.all(attributeFetchPromises);\n        \n    } catch (initError) {\n        console.error(\"Erro durante a inicialização do widget de relatório:\", initError);\n        self.ctx.$scope.errorMessage = initError.message || \"Ocorreu um erro inesperado ao inicializar.\";\n    } finally {\n        self.ctx.$scope.isLoading = false;\n        resolveInitializationPromise();\n        self.ctx.detectChanges();\n    }\n};\n\nasync function triggerDataFetch() {\n    if (!self.ctx.$scope.reportData || self.ctx.$scope.reportData.length === 0) {\n        console.log(\"Relatório: Nenhum dispositivo com atributos para buscar dados.\");\n        return;\n    }\n\n    self.ctx.$scope.isLoading = true;\n    self.ctx.$scope.errorMessage = null; // Clear previous general errors\n    // Reset consumption and errors for devices before fetching new data\n    self.ctx.$scope.reportData.forEach(device => {\n        device.consumptionKwh = null;\n        if (!device.centralId || device.slaveId === null) { // If attributes were missing, keep that error\n            // device.error is already set from onInit\n        } else {\n            device.error = null; // Clear previous API errors for this device\n        }\n    });\n    self.ctx.detectChanges(); // Reflect clearing before fetch\n\n    const devicesToFetch = self.ctx.$scope.reportData\n        .filter(d => d.centralId && d.slaveId !== null && !d.error) // Only fetch for devices with attributes and no init error\n        .map(d => ({ centralId: d.centralId, slaveId: d.slaveId }));\n\n    console.log(\"Report Data (before API call, after reset):\", JSON.stringify(self.ctx.$scope.reportData));\n    console.log(\"Devices to fetch:\", JSON.stringify(devicesToFetch));\n\n    if (devicesToFetch.length === 0) {\n        self.ctx.$scope.isLoading = false;\n        console.log(\"Relatório: Nenhum dispositivo válido para buscar dados de consumo.\");\n        self.ctx.detectChanges();\n        return;\n    }\n\n    try {\n        const params = {\n            devices: devicesToFetch,\n            startTs: new Date(self.ctx.timeWindow.minTime).toISOString(),\n            endTs: new Date(self.ctx.timeWindow.maxTime).toISOString(),\n            timezone: self.ctx.timeWindow.timezone || undefined \n        };\n\n        const response = await fetch(`${self.ctx.$scope.apiBaseUrl}/api/v1/energy-readings/batch-period-sum`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(params)\n        });\n\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({ error: `API request failed with status ${response.status}` }));\n            throw new Error(errorData.error || `API request failed with status ${response.status}`);\n        }\n\n        const consumptionResults = await response.json();\n        console.log(\"API Consumption Results:\", JSON.stringify(consumptionResults));\n\n        // Update reportData with results by creating a new array\n        self.ctx.$scope.reportData = self.ctx.$scope.reportData.map(deviceInReport => {\n            console.log(`Attempting to match device: RID=${deviceInReport.entityId}, CID=${deviceInReport.centralId}, SID=${deviceInReport.slaveId}, Name=${deviceInReport.deviceName}`);\n            if (deviceInReport.centralId && deviceInReport.slaveId !== null) {\n                const resultForDevice = consumptionResults.find(\n                    r => r.centralId === deviceInReport.centralId && r.slaveId === deviceInReport.slaveId\n                );\n                console.log(`Found API result for ${deviceInReport.deviceName}?: `, resultForDevice ? JSON.stringify(resultForDevice) : 'No match found');\n                if (resultForDevice) {\n                    if (resultForDevice.error) {\n                        return {\n                            ...deviceInReport,\n                            consumptionKwh: null,\n                            error: resultForDevice.error\n                        };\n                    } else {\n                        return {\n                            ...deviceInReport,\n                            consumptionKwh: resultForDevice.consumptionKwh,\n                            error: null // Clear any previous error if data is successful\n                        };\n                    }\n                }\n            }\n            return deviceInReport; // Return original if no match or no valid IDs to match\n        });\n\n    } catch (fetchError) {\n        console.error(\"Erro ao buscar dados de consumo em lote:\", fetchError);\n        self.ctx.$scope.errorMessage = fetchError.message || \"Falha ao buscar dados de consumo.\";\n    } finally {\n        self.ctx.$scope.isLoading = false;\n        console.log(\"Report Data (after merge attempt):\", JSON.stringify(self.ctx.$scope.reportData));\n        self.ctx.detectChanges();\n    }\n}\n\nself.onDataUpdated = async function() {\n    await self.initializationPromise;\n    await triggerDataFetch();\n};\n\nself.onTimewindowChanged = async function(newTimeWindow) {\n    await self.initializationPromise;\n    // self.ctx.timeWindow = newTimeWindow; // Already updated by ThingsBoard before this call\n    await triggerDataFetch();\n};\n\n// self.ctx.$scope.exportToCSV = function() {\n//     if (!self.ctx.$scope.reportData || self.ctx.$scope.reportData.length === 0) {\n//         return;\n//     }\n// \n//     const decimals = self.ctx.$scope.consumptionDecimals;\n//     let csvContent = \"Device Name,Consumption in the period (kWh)\\n\"; // Header\n// \n//     self.ctx.$scope.reportData.forEach(device => {\n//         const deviceName = device.deviceName.replace(/\"/g, '\"\"'); // Escape double quotes\n//         let consumptionValue = 'N/A';\n//         if (device.error) {\n//             consumptionValue = `Error: ${device.error.replace(/\"/g, '\"\"')}`;\n//         } else if (device.consumptionKwh !== null) {\n//             consumptionValue = device.consumptionKwh.toFixed(decimals);\n//         }\n//         csvContent += `\"${deviceName}\",\"${consumptionValue}\"\\n`;\n//     });\n// \n//     const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n//     const link = document.createElement(\"a\");\n//     if (link.download !== undefined) { // feature detection\n//         const url = URL.createObjectURL(blob);\n//         link.setAttribute(\"href\", url);\n//         link.setAttribute(\"download\", self.ctx.$scope.exportFileName);\n//         link.style.visibility = 'hidden';\n//         document.body.appendChild(link);\n//         link.click();\n//         document.body.removeChild(link);\n//         URL.revokeObjectURL(url);\n//     } else {\n//         // Fallback for older browsers or environments where download attribute is not supported\n//         alert(\"CSV export via direct download is not supported in your browser. Please try a modern browser.\");\n//         // Or, potentially, display the CSV content in a modal for copy-pasting.\n//     }\n// }; ",
      "settingsSchema" : "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"type\": \"string\",\r\n                \"title\": \"Título do Card\"\r\n            },\r\n            \"measurement\":{\r\n                \"type\":\"string\",\r\n                \"title\":\"Tipo de medição\"\r\n            }\r\n            \r\n        },\r\n        \"required\": [\"title\"]\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n        \"measurement\"\r\n        \r\n        \r\n    ]\r\n}",
      "dataKeySettingsSchema" : "{}",
      "latestDataKeySettingsSchema" : "{}",
      "settingsDirective" : "",
      "dataKeySettingsDirective" : "",
      "latestDataKeySettingsDirective" : "tb-value-card-widget-settings",
      "hasBasicMode" : true,
      "basicModeDirective" : "",
      "defaultConfig" : "{\"showTitle\":false,\"backgroundColor\":\"rgba(0, 0, 0, 0)\",\"color\":\"rgba(33, 186, 79, 0.87)\",\"padding\":\"0px\",\"settings\":{\"title\":\"Título do Card\"},\"title\":\"Energy Report\",\"dropShadow\":true,\"enableFullscreen\":false,\"titleStyle\":null,\"mobileHeight\":null,\"configMode\":\"advanced\",\"actions\":{},\"showTitleIcon\":false,\"titleIcon\":\"thermostat\",\"iconColor\":\"#1F6BDD\",\"useDashboardTimewindow\":false,\"displayTimewindow\":false,\"titleFont\":{\"size\":16,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"500\",\"style\":\"normal\",\"lineHeight\":\"24px\"},\"titleColor\":\"rgba(0, 0, 0, 0.87)\",\"titleTooltip\":\"\",\"widgetStyle\":{},\"widgetCss\":\"\",\"pageSize\":1024,\"units\":\"\",\"decimals\":null,\"noDataDisplayMessage\":\"\",\"timewindowStyle\":{\"showIcon\":false,\"iconSize\":\"24px\",\"icon\":null,\"iconPosition\":\"left\",\"font\":{\"size\":12,\"sizeUnit\":\"px\",\"family\":\"Roboto\",\"weight\":\"400\",\"style\":\"normal\",\"lineHeight\":\"16px\"},\"color\":\"rgba(0, 0, 0, 0.38)\",\"displayTypePrefix\":true},\"margin\":\"0px\",\"borderRadius\":\"0px\",\"iconSize\":\"0px\",\"timewindow\":{\"realtime\":{\"timewindowMs\":86400000}},\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.0049099568976449515,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin 2\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.29530602333210765,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"}],\"alarmFilterConfig\":{\"statusList\":[\"ACTIVE\"]}}],\"enableDataExport\":false}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "4b592d60-3457-11f0-8cbd-2b87fdb093e1"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}